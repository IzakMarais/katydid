//  Copyright 2015 Walter Schulze
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// package interp_test

// import (
// 	"github.com/katydid/katydid/funcs"
// 	. "github.com/katydid/katydid/lang/combinator"
// 	"github.com/katydid/katydid/lang/interp"
// 	"github.com/katydid/katydid/tests"
// 	"reflect"
// 	"testing"
// )

// func Implements(g *lang.Grammar, typ reflect.Type) []interface{} {
// 	var is []interface{}
// 	fs := GetAllLeafs(g)
// 	for _, f := range fs {
// 		is = append(is, compose.FuncImplements(f, typ)...)
// 	}
// 	return is
// }

// type injectableInt struct {
// 	V funcs.ConstInt
// }

// func (this *injectableInt) Eval() int64 {
// 	return this.V.Eval()
// }

// func (this *injectableInt) SetValue(v int64) {
// 	this.V = funcs.IntConst(v)
// }

// func (this *injectableInt) IsVariable() {
// 	//If this method is not implemented this function will probably be trimmed
// }

// func init() {
// 	funcs.Register("inject", new(injectableInt))
// }

// type InjectableInt interface {
// 	SetValue(v int64)
// }

// var injectPerson = G{
// 	"main": MatchTree(
// 		Any(),
// 		MatchIn("Addresses",
// 			Any(),
// 			MatchField("Number", `eq($int, inject(int(0)))`),
// 			Any(),
// 		),
// 		Any(),
// 	),
// }

// func testInject(t *testing.T, num int64) bool {
// 	grammar := injectPerson.Grammar()
// 	typ := reflect.TypeOf((*InjectableInt)(nil)).Elem()
// 	instances := grammar.Implements(typ)
// 	for _, instance := range instances {
// 		instance.(InjectableInt).SetValue(num)
// 	}
// 	scanner := newReflectScanner(tests.RobertPerson)
// 	return interp.Interpret(grammar, scanner)
// }

// func TestInjectPositive(t *testing.T) {
// 	if !testInject(t, 456) {
// 		t.Fatalf("expected match")
// 	}
// }

// func TestInjectNegative(t *testing.T) {
// 	if testInject(t, 123) {
// 		t.Fatalf("expected non match")
// 	}
// }
