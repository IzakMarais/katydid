AllExpr
  : Expr Space
  | Expr
  | BuiltIn Space << &expr.Expr{BuiltIn: $0.(*expr.BuiltIn)}, nil >>
  | BuiltIn << &expr.Expr{BuiltIn: $0.(*expr.BuiltIn)}, nil >>
  ;

Expr
  : SpaceTerminal << &expr.Expr{Terminal: $0.(*expr.Terminal)}, nil >>
  | Function << &expr.Expr{Function: $0.(*expr.Function)}, nil >>
  | List << &expr.Expr{List: $0.(*expr.List)}, nil >>
  ;

Name
  : Space Literal << expr.NewSDTName($0.(*expr.Space), $1.(*expr.Terminal)), nil >>
  | Literal       << expr.NewSDTName(nil, $0.(*expr.Terminal)), nil >>
  | Space id      << expr.NewSDTName($0.(*expr.Space), &expr.Terminal{StringValue: proto.String(newString($1))}), nil >>
  | id            << expr.NewSDTName(nil, &expr.Terminal{StringValue: proto.String(newString($0))}), nil >>
  ;

NameExpr
  : Underscore   << &expr.NameExpr{AnyName: &expr.AnyName{$0.(*expr.Keyword)}}, nil >>
  | Name
  | Exclamation OpenParen NameExpr CloseParen <<
    &expr.NameExpr{AnyNameExcept: &expr.AnyNameExcept{
      Exclamation: $0.(*expr.Keyword),
      OpenParen: $1.(*expr.Keyword),
      Except: $2.(*expr.NameExpr),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | StartNameChoice
  ;

StartNameChoice
  : OpenParen NameExpr Pipe ContinueNameChoice CloseParen <<
    &expr.NameExpr{NameChoice: &expr.NameChoice{
      OpenParen: $0.(*expr.Keyword),
      Left: $1.(*expr.NameExpr),
      Pipe: $2.(*expr.Keyword),
      Right: $3.(*expr.NameExpr),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  ;

ContinueNameChoice
  : NameExpr
  | ContinueNameChoice Pipe NameExpr <<
    &expr.NameExpr{NameChoice: &expr.NameChoice{
      Left: $0.(*expr.NameExpr),
      Pipe: $1.(*expr.Keyword),
      Right: $2.(*expr.NameExpr),
    }}, nil
  >>
  ;

Function
  : Space id OpenParen Exprs CloseParen << &expr.Function{Before: $0.(*expr.Space), Name: newString($1), OpenParen: $2.(*expr.Keyword), Params: $3.([]*expr.Expr), CloseParen: $4.(*expr.Keyword)}, nil >>
  | Space id OpenParen CloseParen << &expr.Function{Before: $0.(*expr.Space), Name: newString($1), OpenParen: $2.(*expr.Keyword), CloseParen: $3.(*expr.Keyword)}, nil >>
  | id OpenParen Exprs CloseParen << &expr.Function{Name: newString($0), OpenParen: $1.(*expr.Keyword), Params: $2.([]*expr.Expr), CloseParen: $3.(*expr.Keyword)}, nil >>
  | id OpenParen CloseParen << &expr.Function{Name: newString($0), OpenParen: $1.(*expr.Keyword), CloseParen: $2.(*expr.Keyword)}, nil >>
  ;

BuiltIn
  : EqualEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | ExclamationEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | LessThan Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | GreaterThan Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | GreaterEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | LessEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | TildeEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | StarEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | CaretEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | DollarEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | ColonColon Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  ;

List
  : Space ListType OpenCurly Exprs CloseCurly << &expr.List{Before: $0.(*expr.Space), Type: $1.(types.Type), OpenCurly: $2.(*expr.Keyword), Elems: $3.([]*expr.Expr), CloseCurly: $4.(*expr.Keyword)}, nil >>
  | ListType OpenCurly Exprs CloseCurly << &expr.List{Type: $0.(types.Type), OpenCurly: $1.(*expr.Keyword), Elems: $2.([]*expr.Expr), CloseCurly: $3.(*expr.Keyword)}, nil >>
  | Space ListType OpenCurly CloseCurly << &expr.List{Before: $0.(*expr.Space), Type: $1.(types.Type), OpenCurly: $2.(*expr.Keyword), CloseCurly: $3.(*expr.Keyword)}, nil >>
  | ListType OpenCurly CloseCurly << &expr.List{Type: $0.(types.Type), OpenCurly: $1.(*expr.Keyword), CloseCurly: $2.(*expr.Keyword)}, nil >>
  ;

Exprs
  : Expr << []*expr.Expr{$0.(*expr.Expr)}, nil >>
  | Exprs Comma Expr << append($0.([]*expr.Expr), expr.SetExprComma($2, $1)), nil >>
  ;

ListType
  : "[]bool" << types.LIST_BOOL, nil >>
  | "[]int" << types.LIST_INT, nil >>
  | "[]uint" << types.LIST_UINT, nil >>
  | "[]double" << types.LIST_DOUBLE, nil >>
  | "[]string" << types.LIST_STRING, nil >>
  | "[][]byte" << types.LIST_BYTES, nil >>
  ;

SpaceTerminal
  : Terminal << $0, nil >>
  | Space Terminal << expr.SetTerminalSpace($1, $0), nil >>
  ;

Literal
  : Bool << expr.NewBoolTerminal($0), nil >>
  | int_lit << expr.NewIntTerminal(newString($0)) >>
  | uint_lit << expr.NewUintTerminal(newString($0)) >>
  | double_lit << expr.NewDoubleTerminal(newString($0)) >>
  | string_lit << expr.NewStringTerminal(newString($0)) >>
  | bytes_lit << expr.NewBytesTerminal(newString($0)) >>
  ;

Terminal
  : Literal
  | bool_var << expr.NewVariableTerminal(types.SINGLE_BOOL) >>
  | int_var << expr.NewVariableTerminal(types.SINGLE_INT) >>
  | uint_var << expr.NewVariableTerminal(types.SINGLE_UINT) >>
  | double_var << expr.NewVariableTerminal(types.SINGLE_DOUBLE) >>
  | string_var << expr.NewVariableTerminal(types.SINGLE_STRING) >>
  | bytes_var << expr.NewVariableTerminal(types.SINGLE_BYTES) >>
  ;

Bool
  : "true" << true, nil >>
  | "false" << false, nil >>
  ;
