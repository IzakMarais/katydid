AllExpr
  : Expr Space
  | Expr
  | BuiltIn Space << &expr.Expr{BuiltIn: $0.(*expr.BuiltIn)}, nil >>
  | BuiltIn << &expr.Expr{BuiltIn: $0.(*expr.BuiltIn)}, nil >>
  ;

Expr
  : SpaceTerminal << &expr.Expr{Terminal: $0.(*expr.Terminal)}, nil >>
  | Function << &expr.Expr{Function: $0.(*expr.Function)}, nil >>
  | List << &expr.Expr{List: $0.(*expr.List)}, nil >>
  ;

Function
  : Space id OpenParen Exprs CloseParen << &expr.Function{Before: $0.(*expr.Space), Name: newString($1), OpenParen: $2.(*expr.Keyword), Params: $3.([]*expr.Expr), CloseParen: $4.(*expr.Keyword)}, nil >>
  | Space id OpenParen CloseParen << &expr.Function{Before: $0.(*expr.Space), Name: newString($1), OpenParen: $2.(*expr.Keyword), CloseParen: $3.(*expr.Keyword)}, nil >>
  | id OpenParen Exprs CloseParen << &expr.Function{Name: newString($0), OpenParen: $1.(*expr.Keyword), Params: $2.([]*expr.Expr), CloseParen: $3.(*expr.Keyword)}, nil >>
  | id OpenParen CloseParen << &expr.Function{Name: newString($0), OpenParen: $1.(*expr.Keyword), CloseParen: $2.(*expr.Keyword)}, nil >>
  ;

BuiltIn
  : EqualEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | ExclamationEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | LessThan Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | GreaterThan Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | GreaterEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | LessEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | TildeEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | StarEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | CaretEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | DollarEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | ColonColon Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  ;

List
  : Space ListType OpenCurly Exprs CloseCurly << &expr.List{Before: $0.(*expr.Space), Type: $1.(types.Type), OpenCurly: $2.(*expr.Keyword), Elems: $3.([]*expr.Expr), CloseCurly: $4.(*expr.Keyword)}, nil >>
  | ListType OpenCurly Exprs CloseCurly << &expr.List{Type: $0.(types.Type), OpenCurly: $1.(*expr.Keyword), Elems: $2.([]*expr.Expr), CloseCurly: $3.(*expr.Keyword)}, nil >>
  | Space ListType OpenCurly CloseCurly << &expr.List{Before: $0.(*expr.Space), Type: $1.(types.Type), OpenCurly: $2.(*expr.Keyword), CloseCurly: $3.(*expr.Keyword)}, nil >>
  | ListType OpenCurly CloseCurly << &expr.List{Type: $0.(types.Type), OpenCurly: $1.(*expr.Keyword), CloseCurly: $2.(*expr.Keyword)}, nil >>
  ;

Exprs
  : Expr << []*expr.Expr{$0.(*expr.Expr)}, nil >>
  | Exprs Comma Expr << append($0.([]*expr.Expr), expr.SetExprComma($2, $1)), nil >>
  ;

ListType
  : "[]bool" << types.LIST_BOOL, nil >>
  | "[]int" << types.LIST_INT, nil >>
  | "[]uint" << types.LIST_UINT, nil >>
  | "[]double" << types.LIST_DOUBLE, nil >>
  | "[]string" << types.LIST_STRING, nil >>
  | "[][]byte" << types.LIST_BYTES, nil >>
  ;

SpaceTerminal
  : Terminal << $0, nil >>
  | Space Terminal << expr.SetTerminalSpace($1, $0), nil >>
  ;

Literal
  : Bool << expr.NewBoolTerminal($0), nil >>
  | int_lit << expr.NewIntTerminal(newString($0)) >>
  | uint_lit << expr.NewUintTerminal(newString($0)) >>
  | double_lit << expr.NewDoubleTerminal(newString($0)) >>
  | string_lit << expr.NewStringTerminal(newString($0)) >>
  | bytes_lit << expr.NewBytesTerminal(newString($0)) >>
  ;

Terminal
  : Literal
  | bool_var << expr.NewVariableTerminal(types.SINGLE_BOOL) >>
  | int_var << expr.NewVariableTerminal(types.SINGLE_INT) >>
  | uint_var << expr.NewVariableTerminal(types.SINGLE_UINT) >>
  | double_var << expr.NewVariableTerminal(types.SINGLE_DOUBLE) >>
  | string_var << expr.NewVariableTerminal(types.SINGLE_STRING) >>
  | bytes_var << expr.NewVariableTerminal(types.SINGLE_BYTES) >>
  ;

Bool
  : "true" << true, nil >>
  | "false" << false, nil >>
  ;
