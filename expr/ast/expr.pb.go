// Code generated by protoc-gen-gogo.
// source: expr.proto
// DO NOT EDIT!

/*
Package expr is a generated protocol buffer package.

It is generated from these files:
	expr.proto

It has these top-level messages:
	Expr
	List
	Function
	BuiltIn
	Terminal
	Variable
	Keyword
	Space
*/
package expr

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import types "github.com/katydid/katydid/types"

import bytes "bytes"

import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Expr struct {
	Comma            *Keyword  `protobuf:"bytes,1,opt,name=Comma" json:"Comma,omitempty"`
	Terminal         *Terminal `protobuf:"bytes,2,opt,name=Terminal" json:"Terminal,omitempty"`
	List             *List     `protobuf:"bytes,3,opt,name=List" json:"List,omitempty"`
	Function         *Function `protobuf:"bytes,4,opt,name=Function" json:"Function,omitempty"`
	BuiltIn          *BuiltIn  `protobuf:"bytes,5,opt,name=BuiltIn" json:"BuiltIn,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Expr) Reset()      { *m = Expr{} }
func (*Expr) ProtoMessage() {}

func (m *Expr) GetComma() *Keyword {
	if m != nil {
		return m.Comma
	}
	return nil
}

func (m *Expr) GetTerminal() *Terminal {
	if m != nil {
		return m.Terminal
	}
	return nil
}

func (m *Expr) GetList() *List {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *Expr) GetFunction() *Function {
	if m != nil {
		return m.Function
	}
	return nil
}

func (m *Expr) GetBuiltIn() *BuiltIn {
	if m != nil {
		return m.BuiltIn
	}
	return nil
}

type List struct {
	Before           *Space     `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Type             types.Type `protobuf:"varint,2,opt,name=Type,enum=types.Type" json:"Type"`
	OpenCurly        *Keyword   `protobuf:"bytes,3,opt,name=OpenCurly" json:"OpenCurly,omitempty"`
	Elems            []*Expr    `protobuf:"bytes,4,rep,name=Elems" json:"Elems,omitempty"`
	CloseCurly       *Keyword   `protobuf:"bytes,5,opt,name=CloseCurly" json:"CloseCurly,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *List) Reset()      { *m = List{} }
func (*List) ProtoMessage() {}

func (m *List) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *List) GetType() types.Type {
	if m != nil {
		return m.Type
	}
	return types.UNKNOWN
}

func (m *List) GetOpenCurly() *Keyword {
	if m != nil {
		return m.OpenCurly
	}
	return nil
}

func (m *List) GetElems() []*Expr {
	if m != nil {
		return m.Elems
	}
	return nil
}

func (m *List) GetCloseCurly() *Keyword {
	if m != nil {
		return m.CloseCurly
	}
	return nil
}

type Function struct {
	Before           *Space   `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Name             string   `protobuf:"bytes,2,opt,name=Name" json:"Name"`
	OpenParen        *Keyword `protobuf:"bytes,3,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Params           []*Expr  `protobuf:"bytes,4,rep,name=Params" json:"Params,omitempty"`
	CloseParen       *Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Function) Reset()      { *m = Function{} }
func (*Function) ProtoMessage() {}

func (m *Function) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Function) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Function) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Function) GetParams() []*Expr {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Function) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type BuiltIn struct {
	Symbol           *Keyword `protobuf:"bytes,1,opt,name=Symbol" json:"Symbol,omitempty"`
	Expr             *Expr    `protobuf:"bytes,2,opt,name=Expr" json:"Expr,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *BuiltIn) Reset()      { *m = BuiltIn{} }
func (*BuiltIn) ProtoMessage() {}

func (m *BuiltIn) GetSymbol() *Keyword {
	if m != nil {
		return m.Symbol
	}
	return nil
}

func (m *BuiltIn) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

type Terminal struct {
	Before           *Space    `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Literal          string    `protobuf:"bytes,2,opt,name=Literal" json:"Literal"`
	DoubleValue      *float64  `protobuf:"fixed64,3,opt,name=DoubleValue" json:"DoubleValue,omitempty"`
	IntValue         *int64    `protobuf:"varint,5,opt,name=IntValue" json:"IntValue,omitempty"`
	UintValue        *uint64   `protobuf:"varint,6,opt,name=UintValue" json:"UintValue,omitempty"`
	BoolValue        *bool     `protobuf:"varint,8,opt,name=BoolValue" json:"BoolValue,omitempty"`
	StringValue      *string   `protobuf:"bytes,9,opt,name=StringValue" json:"StringValue,omitempty"`
	BytesValue       []byte    `protobuf:"bytes,10,opt,name=BytesValue" json:"BytesValue,omitempty"`
	Variable         *Variable `protobuf:"bytes,50,opt,name=Variable" json:"Variable,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Terminal) Reset()      { *m = Terminal{} }
func (*Terminal) ProtoMessage() {}

func (m *Terminal) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Terminal) GetLiteral() string {
	if m != nil {
		return m.Literal
	}
	return ""
}

func (m *Terminal) GetDoubleValue() float64 {
	if m != nil && m.DoubleValue != nil {
		return *m.DoubleValue
	}
	return 0
}

func (m *Terminal) GetIntValue() int64 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *Terminal) GetUintValue() uint64 {
	if m != nil && m.UintValue != nil {
		return *m.UintValue
	}
	return 0
}

func (m *Terminal) GetBoolValue() bool {
	if m != nil && m.BoolValue != nil {
		return *m.BoolValue
	}
	return false
}

func (m *Terminal) GetStringValue() string {
	if m != nil && m.StringValue != nil {
		return *m.StringValue
	}
	return ""
}

func (m *Terminal) GetBytesValue() []byte {
	if m != nil {
		return m.BytesValue
	}
	return nil
}

func (m *Terminal) GetVariable() *Variable {
	if m != nil {
		return m.Variable
	}
	return nil
}

type Variable struct {
	Type             types.Type `protobuf:"varint,2,opt,name=Type,enum=types.Type" json:"Type"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Variable) Reset()      { *m = Variable{} }
func (*Variable) ProtoMessage() {}

func (m *Variable) GetType() types.Type {
	if m != nil {
		return m.Type
	}
	return types.UNKNOWN
}

type Keyword struct {
	Before           *Space `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Value            string `protobuf:"bytes,2,opt,name=Value" json:"Value"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Keyword) Reset()      { *m = Keyword{} }
func (*Keyword) ProtoMessage() {}

func (m *Keyword) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Keyword) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Space struct {
	Space            []string `protobuf:"bytes,1,rep,name=Space" json:"Space,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Space) Reset()      { *m = Space{} }
func (*Space) ProtoMessage() {}

func (m *Space) GetSpace() []string {
	if m != nil {
		return m.Space
	}
	return nil
}

func init() {
	proto.RegisterType((*Expr)(nil), "expr.Expr")
	proto.RegisterType((*List)(nil), "expr.List")
	proto.RegisterType((*Function)(nil), "expr.Function")
	proto.RegisterType((*BuiltIn)(nil), "expr.BuiltIn")
	proto.RegisterType((*Terminal)(nil), "expr.Terminal")
	proto.RegisterType((*Variable)(nil), "expr.Variable")
	proto.RegisterType((*Keyword)(nil), "expr.Keyword")
	proto.RegisterType((*Space)(nil), "expr.Space")
}
func (this *Expr) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Expr)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Comma.Equal(that1.Comma) {
		return false
	}
	if !this.Terminal.Equal(that1.Terminal) {
		return false
	}
	if !this.List.Equal(that1.List) {
		return false
	}
	if !this.Function.Equal(that1.Function) {
		return false
	}
	if !this.BuiltIn.Equal(that1.BuiltIn) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *List) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*List)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.OpenCurly.Equal(that1.OpenCurly) {
		return false
	}
	if len(this.Elems) != len(that1.Elems) {
		return false
	}
	for i := range this.Elems {
		if !this.Elems[i].Equal(that1.Elems[i]) {
			return false
		}
	}
	if !this.CloseCurly.Equal(that1.CloseCurly) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Function) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Function)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if len(this.Params) != len(that1.Params) {
		return false
	}
	for i := range this.Params {
		if !this.Params[i].Equal(that1.Params[i]) {
			return false
		}
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *BuiltIn) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BuiltIn)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Symbol.Equal(that1.Symbol) {
		return false
	}
	if !this.Expr.Equal(that1.Expr) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Terminal) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Terminal)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if this.Literal != that1.Literal {
		return false
	}
	if this.DoubleValue != nil && that1.DoubleValue != nil {
		if *this.DoubleValue != *that1.DoubleValue {
			return false
		}
	} else if this.DoubleValue != nil {
		return false
	} else if that1.DoubleValue != nil {
		return false
	}
	if this.IntValue != nil && that1.IntValue != nil {
		if *this.IntValue != *that1.IntValue {
			return false
		}
	} else if this.IntValue != nil {
		return false
	} else if that1.IntValue != nil {
		return false
	}
	if this.UintValue != nil && that1.UintValue != nil {
		if *this.UintValue != *that1.UintValue {
			return false
		}
	} else if this.UintValue != nil {
		return false
	} else if that1.UintValue != nil {
		return false
	}
	if this.BoolValue != nil && that1.BoolValue != nil {
		if *this.BoolValue != *that1.BoolValue {
			return false
		}
	} else if this.BoolValue != nil {
		return false
	} else if that1.BoolValue != nil {
		return false
	}
	if this.StringValue != nil && that1.StringValue != nil {
		if *this.StringValue != *that1.StringValue {
			return false
		}
	} else if this.StringValue != nil {
		return false
	} else if that1.StringValue != nil {
		return false
	}
	if !bytes.Equal(this.BytesValue, that1.BytesValue) {
		return false
	}
	if !this.Variable.Equal(that1.Variable) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Variable) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Variable)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Keyword) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Keyword)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Space) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Space)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Space) != len(that1.Space) {
		return false
	}
	for i := range this.Space {
		if this.Space[i] != that1.Space[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Expr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&expr.Expr{")
	if this.Comma != nil {
		s = append(s, "Comma: "+fmt.Sprintf("%#v", this.Comma)+",\n")
	}
	if this.Terminal != nil {
		s = append(s, "Terminal: "+fmt.Sprintf("%#v", this.Terminal)+",\n")
	}
	if this.List != nil {
		s = append(s, "List: "+fmt.Sprintf("%#v", this.List)+",\n")
	}
	if this.Function != nil {
		s = append(s, "Function: "+fmt.Sprintf("%#v", this.Function)+",\n")
	}
	if this.BuiltIn != nil {
		s = append(s, "BuiltIn: "+fmt.Sprintf("%#v", this.BuiltIn)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *List) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&expr.List{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.OpenCurly != nil {
		s = append(s, "OpenCurly: "+fmt.Sprintf("%#v", this.OpenCurly)+",\n")
	}
	if this.Elems != nil {
		s = append(s, "Elems: "+fmt.Sprintf("%#v", this.Elems)+",\n")
	}
	if this.CloseCurly != nil {
		s = append(s, "CloseCurly: "+fmt.Sprintf("%#v", this.CloseCurly)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Function) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&expr.Function{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BuiltIn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&expr.BuiltIn{")
	if this.Symbol != nil {
		s = append(s, "Symbol: "+fmt.Sprintf("%#v", this.Symbol)+",\n")
	}
	if this.Expr != nil {
		s = append(s, "Expr: "+fmt.Sprintf("%#v", this.Expr)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Terminal) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&expr.Terminal{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	s = append(s, "Literal: "+fmt.Sprintf("%#v", this.Literal)+",\n")
	if this.DoubleValue != nil {
		s = append(s, "DoubleValue: "+valueToGoStringExpr(this.DoubleValue, "float64")+",\n")
	}
	if this.IntValue != nil {
		s = append(s, "IntValue: "+valueToGoStringExpr(this.IntValue, "int64")+",\n")
	}
	if this.UintValue != nil {
		s = append(s, "UintValue: "+valueToGoStringExpr(this.UintValue, "uint64")+",\n")
	}
	if this.BoolValue != nil {
		s = append(s, "BoolValue: "+valueToGoStringExpr(this.BoolValue, "bool")+",\n")
	}
	if this.StringValue != nil {
		s = append(s, "StringValue: "+valueToGoStringExpr(this.StringValue, "string")+",\n")
	}
	if this.BytesValue != nil {
		s = append(s, "BytesValue: "+valueToGoStringExpr(this.BytesValue, "byte")+",\n")
	}
	if this.Variable != nil {
		s = append(s, "Variable: "+fmt.Sprintf("%#v", this.Variable)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Variable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&expr.Variable{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Keyword) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&expr.Keyword{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Space) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&expr.Space{")
	if this.Space != nil {
		s = append(s, "Space: "+fmt.Sprintf("%#v", this.Space)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringExpr(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringExpr(e map[int32]github_com_gogo_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
