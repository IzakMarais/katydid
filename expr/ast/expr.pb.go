// Code generated by protoc-gen-gogo.
// source: expr.proto
// DO NOT EDIT!

/*
	Package expr is a generated protocol buffer package.

	It is generated from these files:
		expr.proto

	It has these top-level messages:
		Expr
		List
		Function
		BuiltIn
		Terminal
		Variable
		Keyword
		Space
*/
package expr

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import types "github.com/katydid/katydid/expr/types"

import bytes "bytes"

import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Expr struct {
	Comma            *Keyword  `protobuf:"bytes,1,opt,name=Comma" json:"Comma,omitempty"`
	Terminal         *Terminal `protobuf:"bytes,2,opt,name=Terminal" json:"Terminal,omitempty"`
	List             *List     `protobuf:"bytes,3,opt,name=List" json:"List,omitempty"`
	Function         *Function `protobuf:"bytes,4,opt,name=Function" json:"Function,omitempty"`
	BuiltIn          *BuiltIn  `protobuf:"bytes,5,opt,name=BuiltIn" json:"BuiltIn,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Expr) Reset()      { *m = Expr{} }
func (*Expr) ProtoMessage() {}

func (m *Expr) GetComma() *Keyword {
	if m != nil {
		return m.Comma
	}
	return nil
}

func (m *Expr) GetTerminal() *Terminal {
	if m != nil {
		return m.Terminal
	}
	return nil
}

func (m *Expr) GetList() *List {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *Expr) GetFunction() *Function {
	if m != nil {
		return m.Function
	}
	return nil
}

func (m *Expr) GetBuiltIn() *BuiltIn {
	if m != nil {
		return m.BuiltIn
	}
	return nil
}

type List struct {
	Before           *Space     `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Type             types.Type `protobuf:"varint,2,opt,name=Type,enum=types.Type" json:"Type"`
	OpenCurly        *Keyword   `protobuf:"bytes,3,opt,name=OpenCurly" json:"OpenCurly,omitempty"`
	Elems            []*Expr    `protobuf:"bytes,4,rep,name=Elems" json:"Elems,omitempty"`
	CloseCurly       *Keyword   `protobuf:"bytes,5,opt,name=CloseCurly" json:"CloseCurly,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *List) Reset()      { *m = List{} }
func (*List) ProtoMessage() {}

func (m *List) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *List) GetType() types.Type {
	if m != nil {
		return m.Type
	}
	return types.UNKNOWN
}

func (m *List) GetOpenCurly() *Keyword {
	if m != nil {
		return m.OpenCurly
	}
	return nil
}

func (m *List) GetElems() []*Expr {
	if m != nil {
		return m.Elems
	}
	return nil
}

func (m *List) GetCloseCurly() *Keyword {
	if m != nil {
		return m.CloseCurly
	}
	return nil
}

type Function struct {
	Before           *Space   `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Name             string   `protobuf:"bytes,2,opt,name=Name" json:"Name"`
	OpenParen        *Keyword `protobuf:"bytes,3,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Params           []*Expr  `protobuf:"bytes,4,rep,name=Params" json:"Params,omitempty"`
	CloseParen       *Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Function) Reset()      { *m = Function{} }
func (*Function) ProtoMessage() {}

func (m *Function) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Function) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Function) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Function) GetParams() []*Expr {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Function) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type BuiltIn struct {
	Symbol           *Keyword `protobuf:"bytes,1,opt,name=Symbol" json:"Symbol,omitempty"`
	Expr             *Expr    `protobuf:"bytes,2,opt,name=Expr" json:"Expr,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *BuiltIn) Reset()      { *m = BuiltIn{} }
func (*BuiltIn) ProtoMessage() {}

func (m *BuiltIn) GetSymbol() *Keyword {
	if m != nil {
		return m.Symbol
	}
	return nil
}

func (m *BuiltIn) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

type Terminal struct {
	Before           *Space    `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Literal          string    `protobuf:"bytes,2,opt,name=Literal" json:"Literal"`
	DoubleValue      *float64  `protobuf:"fixed64,3,opt,name=DoubleValue" json:"DoubleValue,omitempty"`
	IntValue         *int64    `protobuf:"varint,5,opt,name=IntValue" json:"IntValue,omitempty"`
	UintValue        *uint64   `protobuf:"varint,6,opt,name=UintValue" json:"UintValue,omitempty"`
	BoolValue        *bool     `protobuf:"varint,8,opt,name=BoolValue" json:"BoolValue,omitempty"`
	StringValue      *string   `protobuf:"bytes,9,opt,name=StringValue" json:"StringValue,omitempty"`
	BytesValue       []byte    `protobuf:"bytes,10,opt,name=BytesValue" json:"BytesValue,omitempty"`
	Variable         *Variable `protobuf:"bytes,50,opt,name=Variable" json:"Variable,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Terminal) Reset()      { *m = Terminal{} }
func (*Terminal) ProtoMessage() {}

func (m *Terminal) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Terminal) GetLiteral() string {
	if m != nil {
		return m.Literal
	}
	return ""
}

func (m *Terminal) GetDoubleValue() float64 {
	if m != nil && m.DoubleValue != nil {
		return *m.DoubleValue
	}
	return 0
}

func (m *Terminal) GetIntValue() int64 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *Terminal) GetUintValue() uint64 {
	if m != nil && m.UintValue != nil {
		return *m.UintValue
	}
	return 0
}

func (m *Terminal) GetBoolValue() bool {
	if m != nil && m.BoolValue != nil {
		return *m.BoolValue
	}
	return false
}

func (m *Terminal) GetStringValue() string {
	if m != nil && m.StringValue != nil {
		return *m.StringValue
	}
	return ""
}

func (m *Terminal) GetBytesValue() []byte {
	if m != nil {
		return m.BytesValue
	}
	return nil
}

func (m *Terminal) GetVariable() *Variable {
	if m != nil {
		return m.Variable
	}
	return nil
}

type Variable struct {
	Type             types.Type `protobuf:"varint,2,opt,name=Type,enum=types.Type" json:"Type"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Variable) Reset()      { *m = Variable{} }
func (*Variable) ProtoMessage() {}

func (m *Variable) GetType() types.Type {
	if m != nil {
		return m.Type
	}
	return types.UNKNOWN
}

type Keyword struct {
	Before           *Space `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Value            string `protobuf:"bytes,2,opt,name=Value" json:"Value"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Keyword) Reset()      { *m = Keyword{} }
func (*Keyword) ProtoMessage() {}

func (m *Keyword) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Keyword) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Space struct {
	Space            []string `protobuf:"bytes,1,rep,name=Space" json:"Space,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Space) Reset()      { *m = Space{} }
func (*Space) ProtoMessage() {}

func (m *Space) GetSpace() []string {
	if m != nil {
		return m.Space
	}
	return nil
}

func init() {
	proto.RegisterType((*Expr)(nil), "expr.Expr")
	proto.RegisterType((*List)(nil), "expr.List")
	proto.RegisterType((*Function)(nil), "expr.Function")
	proto.RegisterType((*BuiltIn)(nil), "expr.BuiltIn")
	proto.RegisterType((*Terminal)(nil), "expr.Terminal")
	proto.RegisterType((*Variable)(nil), "expr.Variable")
	proto.RegisterType((*Keyword)(nil), "expr.Keyword")
	proto.RegisterType((*Space)(nil), "expr.Space")
}
func (this *Expr) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Expr)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Comma.Equal(that1.Comma) {
		return false
	}
	if !this.Terminal.Equal(that1.Terminal) {
		return false
	}
	if !this.List.Equal(that1.List) {
		return false
	}
	if !this.Function.Equal(that1.Function) {
		return false
	}
	if !this.BuiltIn.Equal(that1.BuiltIn) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *List) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*List)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.OpenCurly.Equal(that1.OpenCurly) {
		return false
	}
	if len(this.Elems) != len(that1.Elems) {
		return false
	}
	for i := range this.Elems {
		if !this.Elems[i].Equal(that1.Elems[i]) {
			return false
		}
	}
	if !this.CloseCurly.Equal(that1.CloseCurly) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Function) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Function)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if len(this.Params) != len(that1.Params) {
		return false
	}
	for i := range this.Params {
		if !this.Params[i].Equal(that1.Params[i]) {
			return false
		}
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *BuiltIn) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BuiltIn)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Symbol.Equal(that1.Symbol) {
		return false
	}
	if !this.Expr.Equal(that1.Expr) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Terminal) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Terminal)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if this.Literal != that1.Literal {
		return false
	}
	if this.DoubleValue != nil && that1.DoubleValue != nil {
		if *this.DoubleValue != *that1.DoubleValue {
			return false
		}
	} else if this.DoubleValue != nil {
		return false
	} else if that1.DoubleValue != nil {
		return false
	}
	if this.IntValue != nil && that1.IntValue != nil {
		if *this.IntValue != *that1.IntValue {
			return false
		}
	} else if this.IntValue != nil {
		return false
	} else if that1.IntValue != nil {
		return false
	}
	if this.UintValue != nil && that1.UintValue != nil {
		if *this.UintValue != *that1.UintValue {
			return false
		}
	} else if this.UintValue != nil {
		return false
	} else if that1.UintValue != nil {
		return false
	}
	if this.BoolValue != nil && that1.BoolValue != nil {
		if *this.BoolValue != *that1.BoolValue {
			return false
		}
	} else if this.BoolValue != nil {
		return false
	} else if that1.BoolValue != nil {
		return false
	}
	if this.StringValue != nil && that1.StringValue != nil {
		if *this.StringValue != *that1.StringValue {
			return false
		}
	} else if this.StringValue != nil {
		return false
	} else if that1.StringValue != nil {
		return false
	}
	if !bytes.Equal(this.BytesValue, that1.BytesValue) {
		return false
	}
	if !this.Variable.Equal(that1.Variable) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Variable) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Variable)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Keyword) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Keyword)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Space) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Space)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Space) != len(that1.Space) {
		return false
	}
	for i := range this.Space {
		if this.Space[i] != that1.Space[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Expr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&expr.Expr{")
	if this.Comma != nil {
		s = append(s, "Comma: "+fmt.Sprintf("%#v", this.Comma)+",\n")
	}
	if this.Terminal != nil {
		s = append(s, "Terminal: "+fmt.Sprintf("%#v", this.Terminal)+",\n")
	}
	if this.List != nil {
		s = append(s, "List: "+fmt.Sprintf("%#v", this.List)+",\n")
	}
	if this.Function != nil {
		s = append(s, "Function: "+fmt.Sprintf("%#v", this.Function)+",\n")
	}
	if this.BuiltIn != nil {
		s = append(s, "BuiltIn: "+fmt.Sprintf("%#v", this.BuiltIn)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *List) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&expr.List{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.OpenCurly != nil {
		s = append(s, "OpenCurly: "+fmt.Sprintf("%#v", this.OpenCurly)+",\n")
	}
	if this.Elems != nil {
		s = append(s, "Elems: "+fmt.Sprintf("%#v", this.Elems)+",\n")
	}
	if this.CloseCurly != nil {
		s = append(s, "CloseCurly: "+fmt.Sprintf("%#v", this.CloseCurly)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Function) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&expr.Function{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BuiltIn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&expr.BuiltIn{")
	if this.Symbol != nil {
		s = append(s, "Symbol: "+fmt.Sprintf("%#v", this.Symbol)+",\n")
	}
	if this.Expr != nil {
		s = append(s, "Expr: "+fmt.Sprintf("%#v", this.Expr)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Terminal) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&expr.Terminal{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	s = append(s, "Literal: "+fmt.Sprintf("%#v", this.Literal)+",\n")
	if this.DoubleValue != nil {
		s = append(s, "DoubleValue: "+valueToGoStringExpr(this.DoubleValue, "float64")+",\n")
	}
	if this.IntValue != nil {
		s = append(s, "IntValue: "+valueToGoStringExpr(this.IntValue, "int64")+",\n")
	}
	if this.UintValue != nil {
		s = append(s, "UintValue: "+valueToGoStringExpr(this.UintValue, "uint64")+",\n")
	}
	if this.BoolValue != nil {
		s = append(s, "BoolValue: "+valueToGoStringExpr(this.BoolValue, "bool")+",\n")
	}
	if this.StringValue != nil {
		s = append(s, "StringValue: "+valueToGoStringExpr(this.StringValue, "string")+",\n")
	}
	if this.BytesValue != nil {
		s = append(s, "BytesValue: "+valueToGoStringExpr(this.BytesValue, "byte")+",\n")
	}
	if this.Variable != nil {
		s = append(s, "Variable: "+fmt.Sprintf("%#v", this.Variable)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Variable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&expr.Variable{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Keyword) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&expr.Keyword{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Space) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&expr.Space{")
	if this.Space != nil {
		s = append(s, "Space: "+fmt.Sprintf("%#v", this.Space)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringExpr(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringExpr(e map[int32]github_com_gogo_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func (m *Expr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Expr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Comma != nil {
		data[i] = 0xa
		i++
		i = encodeVarintExpr(data, i, uint64(m.Comma.Size()))
		n1, err := m.Comma.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Terminal != nil {
		data[i] = 0x12
		i++
		i = encodeVarintExpr(data, i, uint64(m.Terminal.Size()))
		n2, err := m.Terminal.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.List != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintExpr(data, i, uint64(m.List.Size()))
		n3, err := m.List.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Function != nil {
		data[i] = 0x22
		i++
		i = encodeVarintExpr(data, i, uint64(m.Function.Size()))
		n4, err := m.Function.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.BuiltIn != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintExpr(data, i, uint64(m.BuiltIn.Size()))
		n5, err := m.BuiltIn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *List) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *List) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		data[i] = 0xa
		i++
		i = encodeVarintExpr(data, i, uint64(m.Before.Size()))
		n6, err := m.Before.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	data[i] = 0x10
	i++
	i = encodeVarintExpr(data, i, uint64(m.Type))
	if m.OpenCurly != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintExpr(data, i, uint64(m.OpenCurly.Size()))
		n7, err := m.OpenCurly.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Elems) > 0 {
		for _, msg := range m.Elems {
			data[i] = 0x22
			i++
			i = encodeVarintExpr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CloseCurly != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintExpr(data, i, uint64(m.CloseCurly.Size()))
		n8, err := m.CloseCurly.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Function) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Function) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		data[i] = 0xa
		i++
		i = encodeVarintExpr(data, i, uint64(m.Before.Size()))
		n9, err := m.Before.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	data[i] = 0x12
	i++
	i = encodeVarintExpr(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	if m.OpenParen != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintExpr(data, i, uint64(m.OpenParen.Size()))
		n10, err := m.OpenParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Params) > 0 {
		for _, msg := range m.Params {
			data[i] = 0x22
			i++
			i = encodeVarintExpr(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CloseParen != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintExpr(data, i, uint64(m.CloseParen.Size()))
		n11, err := m.CloseParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BuiltIn) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuiltIn) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Symbol != nil {
		data[i] = 0xa
		i++
		i = encodeVarintExpr(data, i, uint64(m.Symbol.Size()))
		n12, err := m.Symbol.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Expr != nil {
		data[i] = 0x12
		i++
		i = encodeVarintExpr(data, i, uint64(m.Expr.Size()))
		n13, err := m.Expr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Terminal) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Terminal) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		data[i] = 0xa
		i++
		i = encodeVarintExpr(data, i, uint64(m.Before.Size()))
		n14, err := m.Before.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	data[i] = 0x12
	i++
	i = encodeVarintExpr(data, i, uint64(len(m.Literal)))
	i += copy(data[i:], m.Literal)
	if m.DoubleValue != nil {
		data[i] = 0x19
		i++
		i = encodeFixed64Expr(data, i, uint64(math.Float64bits(*m.DoubleValue)))
	}
	if m.IntValue != nil {
		data[i] = 0x28
		i++
		i = encodeVarintExpr(data, i, uint64(*m.IntValue))
	}
	if m.UintValue != nil {
		data[i] = 0x30
		i++
		i = encodeVarintExpr(data, i, uint64(*m.UintValue))
	}
	if m.BoolValue != nil {
		data[i] = 0x40
		i++
		if *m.BoolValue {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.StringValue != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintExpr(data, i, uint64(len(*m.StringValue)))
		i += copy(data[i:], *m.StringValue)
	}
	if m.BytesValue != nil {
		data[i] = 0x52
		i++
		i = encodeVarintExpr(data, i, uint64(len(m.BytesValue)))
		i += copy(data[i:], m.BytesValue)
	}
	if m.Variable != nil {
		data[i] = 0x92
		i++
		data[i] = 0x3
		i++
		i = encodeVarintExpr(data, i, uint64(m.Variable.Size()))
		n15, err := m.Variable.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Variable) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Variable) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x10
	i++
	i = encodeVarintExpr(data, i, uint64(m.Type))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Keyword) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Keyword) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		data[i] = 0xa
		i++
		i = encodeVarintExpr(data, i, uint64(m.Before.Size()))
		n16, err := m.Before.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	data[i] = 0x12
	i++
	i = encodeVarintExpr(data, i, uint64(len(m.Value)))
	i += copy(data[i:], m.Value)
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Space) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Space) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Space) > 0 {
		for _, s := range m.Space {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Expr(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Expr(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintExpr(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Expr) Size() (n int) {
	var l int
	_ = l
	if m.Comma != nil {
		l = m.Comma.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	if m.Terminal != nil {
		l = m.Terminal.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	if m.List != nil {
		l = m.List.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	if m.Function != nil {
		l = m.Function.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	if m.BuiltIn != nil {
		l = m.BuiltIn.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *List) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	n += 1 + sovExpr(uint64(m.Type))
	if m.OpenCurly != nil {
		l = m.OpenCurly.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	if len(m.Elems) > 0 {
		for _, e := range m.Elems {
			l = e.Size()
			n += 1 + l + sovExpr(uint64(l))
		}
	}
	if m.CloseCurly != nil {
		l = m.CloseCurly.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Function) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	l = len(m.Name)
	n += 1 + l + sovExpr(uint64(l))
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovExpr(uint64(l))
		}
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuiltIn) Size() (n int) {
	var l int
	_ = l
	if m.Symbol != nil {
		l = m.Symbol.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Terminal) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	l = len(m.Literal)
	n += 1 + l + sovExpr(uint64(l))
	if m.DoubleValue != nil {
		n += 9
	}
	if m.IntValue != nil {
		n += 1 + sovExpr(uint64(*m.IntValue))
	}
	if m.UintValue != nil {
		n += 1 + sovExpr(uint64(*m.UintValue))
	}
	if m.BoolValue != nil {
		n += 2
	}
	if m.StringValue != nil {
		l = len(*m.StringValue)
		n += 1 + l + sovExpr(uint64(l))
	}
	if m.BytesValue != nil {
		l = len(m.BytesValue)
		n += 1 + l + sovExpr(uint64(l))
	}
	if m.Variable != nil {
		l = m.Variable.Size()
		n += 2 + l + sovExpr(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Variable) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovExpr(uint64(m.Type))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Keyword) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovExpr(uint64(l))
	}
	l = len(m.Value)
	n += 1 + l + sovExpr(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Space) Size() (n int) {
	var l int
	_ = l
	if len(m.Space) > 0 {
		for _, s := range m.Space {
			l = len(s)
			n += 1 + l + sovExpr(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovExpr(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozExpr(x uint64) (n int) {
	return sovExpr(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Expr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comma", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Comma == nil {
				m.Comma = &Keyword{}
			}
			if err := m.Comma.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Terminal == nil {
				m.Terminal = &Terminal{}
			}
			if err := m.Terminal.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.List == nil {
				m.List = &List{}
			}
			if err := m.List.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Function == nil {
				m.Function = &Function{}
			}
			if err := m.Function.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuiltIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuiltIn == nil {
				m.BuiltIn = &BuiltIn{}
			}
			if err := m.BuiltIn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *List) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (types.Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenCurly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenCurly == nil {
				m.OpenCurly = &Keyword{}
			}
			if err := m.OpenCurly.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elems = append(m.Elems, &Expr{})
			if err := m.Elems[len(m.Elems)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseCurly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseCurly == nil {
				m.CloseCurly = &Keyword{}
			}
			if err := m.CloseCurly.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &Expr{})
			if err := m.Params[len(m.Params)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuiltIn) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuiltIn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuiltIn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Symbol == nil {
				m.Symbol = &Keyword{}
			}
			if err := m.Symbol.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Terminal) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Terminal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Terminal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Literal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Literal = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.DoubleValue = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntValue = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UintValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UintValue = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BoolValue = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.StringValue = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesValue = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Variable == nil {
				m.Variable = &Variable{}
			}
			if err := m.Variable.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Variable) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Variable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Variable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (types.Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExpr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Keyword) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keyword: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keyword: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Space) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpr
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Space: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Space: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Space", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpr
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Space = append(m.Space, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpr(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpr
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExpr(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExpr
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExpr
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthExpr
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowExpr
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipExpr(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthExpr = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExpr   = fmt.Errorf("proto: integer overflow")
)
