<< 
import (
  . "github.com/katydid/katydid/viper/ast"
  "github.com/katydid/katydid/expr/ast"
  "github.com/katydid/katydid/expr/types"
  "github.com/katydid/katydid/viper/token"
  "github.com/gogo/protobuf/proto"
  "strconv"
)

func newString(v interface{}) string {
  t := v.(*token.Token)
  return string(t.Lit)
}

func unquote(s1 string) string {
  s, err := strconv.Unquote(s1)
  if err != nil {
    return s1
  }
  return s
}

>>

Start
  : Rules       << &Rules{$0.([]*Rule), nil}, nil >>
  | Rules Space << &Rules{$0.([]*Rule), $1.(*expr.Space)}, nil >>
  ;

Rules
  : Rule        << []*Rule{$0.(*Rule)}, nil >>
  | Rules Rule  << append($0.([]*Rule), $1.(*Rule)), nil >>
  ;

Rule
  : StartRule   << &Rule{Start: $0.(*Start)}, nil >>
  | Final       << &Rule{Final: $0.(*Final)}, nil >>
  | Internal    << &Rule{Internal: $0.(*Internal)}, nil >>
  | Call        << &Rule{Call: $0.(*Call)}, nil >>
  | Return      << &Rule{Return: $0.(*Return)}, nil >>
  ;

StartRule
  : Space "start" Equal State SemiColon <<
    &Start{
      Before: $0.(*expr.Space),
      Eq: $2.(*expr.Keyword),
      State: $3.(*State),
      SemiColon: $4.(*expr.Keyword),
    }, nil
  >>
  | "start" Equal State SemiColon <<
    &Start{
      Eq: $1.(*expr.Keyword),
      State: $2.(*State),
      SemiColon: $3.(*expr.Keyword),
    }, nil
  >>
  ;

Final
  : Space "final" Equal State SemiColon <<
    &Final{
      Before: $0.(*expr.Space),
      Eq: $2.(*expr.Keyword),
      State: $3.(*State),
      SemiColon: $4.(*expr.Keyword),
    }, nil
  >>
  | "final" Equal State SemiColon <<
    &Final{
      Eq: $1.(*expr.Keyword),
      State: $2.(*State),
      SemiColon: $3.(*expr.Keyword),
    }, nil
  >>
  ;

Internal
  : Space "internal" State Expr State SemiColon <<
    &Internal{
      Before: $0.(*expr.Space),
      Src: $2.(*State),
      Expr: $3.(*expr.Expr),
      Dst: $4.(*State),
      SemiColon: $5.(*expr.Keyword),
    }, nil
  >>
  | "internal" State Expr State SemiColon <<
    &Internal{
      Src: $1.(*State),
      Expr: $2.(*expr.Expr),
      Dst: $3.(*State),
      SemiColon: $4.(*expr.Keyword),
    }, nil
  >>
  ;

Call
  : Space "call" State Expr State State SemiColon <<
    &Call{
      Before: $0.(*expr.Space),
      Src: $2.(*State),
      Expr: $3.(*expr.Expr),
      ParentDst: $4.(*State),
      ChildDst: $5.(*State),
      SemiColon: $6.(*expr.Keyword),
    }, nil
  >>
  | "call" State Expr State State SemiColon <<
    &Call{
      Src: $1.(*State),
      Expr: $2.(*expr.Expr),
      ParentDst: $3.(*State),
      ChildDst: $4.(*State),
      SemiColon: $5.(*expr.Keyword),
    }, nil
  >>
  ;

Return
  : Space "return" State State Expr State SemiColon <<
    &Return{
      Before: $0.(*expr.Space),
      ParentSrc: $2.(*State),
      ChildSrc: $3.(*State),
      Expr: $4.(*expr.Expr),
      Dst: $5.(*State),
      SemiColon: $6.(*expr.Keyword),
    }, nil
  >>
  | "return" State State Expr State SemiColon <<
    &Return{
      ParentSrc: $1.(*State),
      ChildSrc: $2.(*State),
      Expr: $3.(*expr.Expr),
      Dst: $4.(*State),
      SemiColon: $5.(*expr.Keyword),
    }, nil
  >>
  ;

State
  : Space id         << &State{Before: $0.(*expr.Space), Name: newString($1)}, nil >>
  | id               << &State{Name: newString($0)}, nil >>
  | Space string_lit << &State{Before: $0.(*expr.Space), Name: newString($1)}, nil >>
  | string_lit       << &State{Name: newString($0)}, nil >>
  ;






