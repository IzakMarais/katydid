// Code generated by protoc-gen-gogo.
// source: viper.proto
// DO NOT EDIT!

/*
	Package viper is a generated protocol buffer package.

	It is generated from these files:
		viper.proto

	It has these top-level messages:
		Rules
		Rule
		Start
		Final
		Internal
		Call
		Return
		State
*/
package viper

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import expr "github.com/katydid/katydid/expr/ast"

import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Rules struct {
	Rules []*Rule     `protobuf:"bytes,1,rep,name=Rules" json:"Rules,omitempty"`
	After *expr.Space `protobuf:"bytes,2,opt,name=After" json:"After,omitempty"`
}

func (m *Rules) Reset()      { *m = Rules{} }
func (*Rules) ProtoMessage() {}

func (m *Rules) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *Rules) GetAfter() *expr.Space {
	if m != nil {
		return m.After
	}
	return nil
}

type Rule struct {
	Start    *Start    `protobuf:"bytes,1,opt,name=Start" json:"Start,omitempty"`
	Final    *Final    `protobuf:"bytes,2,opt,name=Final" json:"Final,omitempty"`
	Internal *Internal `protobuf:"bytes,3,opt,name=Internal" json:"Internal,omitempty"`
	Call     *Call     `protobuf:"bytes,4,opt,name=Call" json:"Call,omitempty"`
	Return   *Return   `protobuf:"bytes,5,opt,name=Return" json:"Return,omitempty"`
}

func (m *Rule) Reset()      { *m = Rule{} }
func (*Rule) ProtoMessage() {}

func (m *Rule) GetStart() *Start {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Rule) GetFinal() *Final {
	if m != nil {
		return m.Final
	}
	return nil
}

func (m *Rule) GetInternal() *Internal {
	if m != nil {
		return m.Internal
	}
	return nil
}

func (m *Rule) GetCall() *Call {
	if m != nil {
		return m.Call
	}
	return nil
}

func (m *Rule) GetReturn() *Return {
	if m != nil {
		return m.Return
	}
	return nil
}

type Start struct {
	Before    *expr.Space   `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Eq        *expr.Keyword `protobuf:"bytes,2,opt,name=Eq" json:"Eq,omitempty"`
	State     *State        `protobuf:"bytes,3,opt,name=State" json:"State,omitempty"`
	SemiColon *expr.Keyword `protobuf:"bytes,4,opt,name=SemiColon" json:"SemiColon,omitempty"`
}

func (m *Start) Reset()      { *m = Start{} }
func (*Start) ProtoMessage() {}

func (m *Start) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Start) GetEq() *expr.Keyword {
	if m != nil {
		return m.Eq
	}
	return nil
}

func (m *Start) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Start) GetSemiColon() *expr.Keyword {
	if m != nil {
		return m.SemiColon
	}
	return nil
}

type Final struct {
	Before    *expr.Space   `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Eq        *expr.Keyword `protobuf:"bytes,2,opt,name=Eq" json:"Eq,omitempty"`
	State     *State        `protobuf:"bytes,3,opt,name=State" json:"State,omitempty"`
	SemiColon *expr.Keyword `protobuf:"bytes,4,opt,name=SemiColon" json:"SemiColon,omitempty"`
}

func (m *Final) Reset()      { *m = Final{} }
func (*Final) ProtoMessage() {}

func (m *Final) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Final) GetEq() *expr.Keyword {
	if m != nil {
		return m.Eq
	}
	return nil
}

func (m *Final) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Final) GetSemiColon() *expr.Keyword {
	if m != nil {
		return m.SemiColon
	}
	return nil
}

type Internal struct {
	Before    *expr.Space   `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Src       *State        `protobuf:"bytes,2,opt,name=Src" json:"Src,omitempty"`
	Expr      *expr.Expr    `protobuf:"bytes,3,opt,name=Expr" json:"Expr,omitempty"`
	Dst       *State        `protobuf:"bytes,4,opt,name=Dst" json:"Dst,omitempty"`
	SemiColon *expr.Keyword `protobuf:"bytes,5,opt,name=SemiColon" json:"SemiColon,omitempty"`
}

func (m *Internal) Reset()      { *m = Internal{} }
func (*Internal) ProtoMessage() {}

func (m *Internal) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Internal) GetSrc() *State {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *Internal) GetExpr() *expr.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Internal) GetDst() *State {
	if m != nil {
		return m.Dst
	}
	return nil
}

func (m *Internal) GetSemiColon() *expr.Keyword {
	if m != nil {
		return m.SemiColon
	}
	return nil
}

type Call struct {
	Before    *expr.Space   `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Src       *State        `protobuf:"bytes,2,opt,name=Src" json:"Src,omitempty"`
	Expr      *expr.Expr    `protobuf:"bytes,3,opt,name=Expr" json:"Expr,omitempty"`
	ParentDst *State        `protobuf:"bytes,4,opt,name=ParentDst" json:"ParentDst,omitempty"`
	ChildDst  *State        `protobuf:"bytes,5,opt,name=ChildDst" json:"ChildDst,omitempty"`
	SemiColon *expr.Keyword `protobuf:"bytes,6,opt,name=SemiColon" json:"SemiColon,omitempty"`
}

func (m *Call) Reset()      { *m = Call{} }
func (*Call) ProtoMessage() {}

func (m *Call) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Call) GetSrc() *State {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *Call) GetExpr() *expr.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Call) GetParentDst() *State {
	if m != nil {
		return m.ParentDst
	}
	return nil
}

func (m *Call) GetChildDst() *State {
	if m != nil {
		return m.ChildDst
	}
	return nil
}

func (m *Call) GetSemiColon() *expr.Keyword {
	if m != nil {
		return m.SemiColon
	}
	return nil
}

type Return struct {
	Before    *expr.Space   `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	ParentSrc *State        `protobuf:"bytes,2,opt,name=ParentSrc" json:"ParentSrc,omitempty"`
	ChildSrc  *State        `protobuf:"bytes,3,opt,name=ChildSrc" json:"ChildSrc,omitempty"`
	Expr      *expr.Expr    `protobuf:"bytes,4,opt,name=Expr" json:"Expr,omitempty"`
	Dst       *State        `protobuf:"bytes,5,opt,name=Dst" json:"Dst,omitempty"`
	SemiColon *expr.Keyword `protobuf:"bytes,6,opt,name=SemiColon" json:"SemiColon,omitempty"`
}

func (m *Return) Reset()      { *m = Return{} }
func (*Return) ProtoMessage() {}

func (m *Return) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Return) GetParentSrc() *State {
	if m != nil {
		return m.ParentSrc
	}
	return nil
}

func (m *Return) GetChildSrc() *State {
	if m != nil {
		return m.ChildSrc
	}
	return nil
}

func (m *Return) GetExpr() *expr.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Return) GetDst() *State {
	if m != nil {
		return m.Dst
	}
	return nil
}

func (m *Return) GetSemiColon() *expr.Keyword {
	if m != nil {
		return m.SemiColon
	}
	return nil
}

type State struct {
	Before *expr.Space `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Name   string      `protobuf:"bytes,2,opt,name=Name" json:"Name"`
}

func (m *State) Reset()      { *m = State{} }
func (*State) ProtoMessage() {}

func (m *State) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *State) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*Rules)(nil), "viper.Rules")
	proto.RegisterType((*Rule)(nil), "viper.Rule")
	proto.RegisterType((*Start)(nil), "viper.Start")
	proto.RegisterType((*Final)(nil), "viper.Final")
	proto.RegisterType((*Internal)(nil), "viper.Internal")
	proto.RegisterType((*Call)(nil), "viper.Call")
	proto.RegisterType((*Return)(nil), "viper.Return")
	proto.RegisterType((*State)(nil), "viper.State")
}
func (this *Rules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&viper.Rules{")
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.After != nil {
		s = append(s, "After: "+fmt.Sprintf("%#v", this.After)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Rule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&viper.Rule{")
	if this.Start != nil {
		s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	}
	if this.Final != nil {
		s = append(s, "Final: "+fmt.Sprintf("%#v", this.Final)+",\n")
	}
	if this.Internal != nil {
		s = append(s, "Internal: "+fmt.Sprintf("%#v", this.Internal)+",\n")
	}
	if this.Call != nil {
		s = append(s, "Call: "+fmt.Sprintf("%#v", this.Call)+",\n")
	}
	if this.Return != nil {
		s = append(s, "Return: "+fmt.Sprintf("%#v", this.Return)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Start) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&viper.Start{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	if this.Eq != nil {
		s = append(s, "Eq: "+fmt.Sprintf("%#v", this.Eq)+",\n")
	}
	if this.State != nil {
		s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	}
	if this.SemiColon != nil {
		s = append(s, "SemiColon: "+fmt.Sprintf("%#v", this.SemiColon)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Final) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&viper.Final{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	if this.Eq != nil {
		s = append(s, "Eq: "+fmt.Sprintf("%#v", this.Eq)+",\n")
	}
	if this.State != nil {
		s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	}
	if this.SemiColon != nil {
		s = append(s, "SemiColon: "+fmt.Sprintf("%#v", this.SemiColon)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Internal) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&viper.Internal{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	if this.Src != nil {
		s = append(s, "Src: "+fmt.Sprintf("%#v", this.Src)+",\n")
	}
	if this.Expr != nil {
		s = append(s, "Expr: "+fmt.Sprintf("%#v", this.Expr)+",\n")
	}
	if this.Dst != nil {
		s = append(s, "Dst: "+fmt.Sprintf("%#v", this.Dst)+",\n")
	}
	if this.SemiColon != nil {
		s = append(s, "SemiColon: "+fmt.Sprintf("%#v", this.SemiColon)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Call) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&viper.Call{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	if this.Src != nil {
		s = append(s, "Src: "+fmt.Sprintf("%#v", this.Src)+",\n")
	}
	if this.Expr != nil {
		s = append(s, "Expr: "+fmt.Sprintf("%#v", this.Expr)+",\n")
	}
	if this.ParentDst != nil {
		s = append(s, "ParentDst: "+fmt.Sprintf("%#v", this.ParentDst)+",\n")
	}
	if this.ChildDst != nil {
		s = append(s, "ChildDst: "+fmt.Sprintf("%#v", this.ChildDst)+",\n")
	}
	if this.SemiColon != nil {
		s = append(s, "SemiColon: "+fmt.Sprintf("%#v", this.SemiColon)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Return) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&viper.Return{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	if this.ParentSrc != nil {
		s = append(s, "ParentSrc: "+fmt.Sprintf("%#v", this.ParentSrc)+",\n")
	}
	if this.ChildSrc != nil {
		s = append(s, "ChildSrc: "+fmt.Sprintf("%#v", this.ChildSrc)+",\n")
	}
	if this.Expr != nil {
		s = append(s, "Expr: "+fmt.Sprintf("%#v", this.Expr)+",\n")
	}
	if this.Dst != nil {
		s = append(s, "Dst: "+fmt.Sprintf("%#v", this.Dst)+",\n")
	}
	if this.SemiColon != nil {
		s = append(s, "SemiColon: "+fmt.Sprintf("%#v", this.SemiColon)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *State) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&viper.State{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringViper(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringViper(e map[int32]github_com_gogo_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func (this *Rule) GetValue() interface{} {
	if this.Start != nil {
		return this.Start
	}
	if this.Final != nil {
		return this.Final
	}
	if this.Internal != nil {
		return this.Internal
	}
	if this.Call != nil {
		return this.Call
	}
	if this.Return != nil {
		return this.Return
	}
	return nil
}

func (this *Rule) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *Start:
		this.Start = vt
	case *Final:
		this.Final = vt
	case *Internal:
		this.Internal = vt
	case *Call:
		this.Call = vt
	case *Return:
		this.Return = vt
	default:
		return false
	}
	return true
}
