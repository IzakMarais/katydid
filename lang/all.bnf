//  DO NOT EDIT
//  This is generated file, see build.sh
//  Sources: ../expr/license.bnf ../expr/lexer.bnf, lang.bnf, ../expr/expr.bnf, ../expr/keyword.bnf

//  Copyright 2013 Walter Schulze
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

_lineComment : '/' '/' {.} '\n' ;

_blockComment : '/' '*' {. | '*'} '*' '/' ;

_comment : _lineComment | _blockComment ;

_ws : ' ' | '\t' | '\n' | '\r' ; //whitespace

space : _comment | _ws ;

_decimal_digit : '0' - '9' ;
_octal_digit : '0' - '7' ;
_hex_digit : '0' - '9' | 'A' - 'F' | 'a' - 'f';

_int_lit     : _decimal_lit | _octal_lit | _hex_lit ;
_decimal_lit : ( '1' - '9' ) { _decimal_digit } ;
_octal_lit   : '0' { _octal_digit } ;
_hex_lit     : '0' ( 'x' | 'X' ) _hex_digit { _hex_digit } ;

_singed_int_lit : ['-'] _int_lit ;

int_lit: _int '(' _singed_int_lit ')' ;
uint_lit: _uint '(' _int_lit ')' ;

_decimals  : _decimal_digit { _decimal_digit } ;
_exponent  : ( 'e' | 'E' ) [ '+' | '-' ] _decimals ;

_float_lit : ( _decimals '.' _decimals _exponent )
			| ( _decimals '.' ( _decimals | _exponent ) )
          	| ( _decimals _exponent )
          	| ( '.' _decimals [ _exponent ] ) 
          	;

double_lit: _double '(' ['-'] ( _float_lit | _int_lit ) ')' ;

_upcase : 'A'-'Z' ;
_lowcase : 'a'-'z' ;
_id_char : _upcase | _lowcase | '_' | _decimal_digit ;

_id : (_upcase | _lowcase | '_' ) {_id_char} ;
id : _id ;

_double : 'd' 'o' 'u' 'b' 'l' 'e' ;
_int : 'i' 'n' 't';
_uint : 'u' 'i' 'n' 't';
_bytes : '[' ']' 'b' 'y' 't' 'e' ;
_string : 's' 't' 'r' 'i' 'n' 'g' ;
_bool : 'b' 'o' 'o' 'l' ;

_qualid : _id { '.' _id } ;

double_var : '$' _double ;
int_var : '$' _int ;
uint_var : '$' _uint ;
bytes_var : '$' _bytes ;
string_var : '$' _string ;
bool_var : '$' _bool ;

_big_u_value      : '\\' 'U' _hex_digit _hex_digit _hex_digit _hex_digit
                            _hex_digit _hex_digit _hex_digit _hex_digit ;
_little_u_value   : '\\' 'u' _hex_digit _hex_digit _hex_digit _hex_digit ;
_hex_byte_u_value   : '\\' 'x' _hex_digit _hex_digit ;

_octal_byte_u_value : '\\' _octal_digit _octal_digit _octal_digit ;
_byte_value       : _octal_byte_u_value | _hex_byte_u_value ;
_raw_string : '`' {.} '`' ;
_escaped_char     : '\\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '\'' | '"' ) ;
_unicode_value    : . | _little_u_value | _big_u_value | _escaped_char ;
_interpreted_string : '"' { _unicode_value | _byte_value } '"' ;

string_lit : _raw_string | _interpreted_string ;

_char_lit	: '\'' (_unicode_value | _byte_value) '\'' ;

_byte_elem : _int_lit | _char_lit ;

bytes_lit : _bytes '{' { _ws } [ _byte_elem { { _ws } ',' { _ws } _byte_elem } ] { _ws } '}' ;
/*
schema5.Mail {
  Any*,
  Communication {
    Any*,
    TimeRange {
      Any*,
      StartTime ge(var, 1984),
Any* },
Any* },
Any* }
*/

/*
schema5.Mail { WithSome Communication {
  WithSome Content { WithSome Participations {
    WithSome Identities {
      WithSome Email {
        WithSome Value.eq(”you@youhoo.com”)
      }
}&
WithSome Role.eq(enum(”schema5.Role.RoleSender”)) }}
}}
*/

/*
schema5.Mail { Communication { Content {
  Participations {
    Identities {
      Email { Value.eq(”you@youhoo.com”) }
},
Role.eq(enum(”schema5.Role.RoleSender”)) }}
}}
*/

/*
schema5.Mail { Communication {
  Content { Object { Mime : mimeObject } } }
}}
mimeObject = {
  Container {
    ( Type.eq(”image”), Subtype.eq(”bmp”) )
    | ( Parts: mimeObject )
    | ( Leaf {
      Type.eq(”image”),
Subtype.eq(”bmp”) })
} }
*/

/*
FlowDescriptor {
  Any*,
  Stack.eq(frameType1),
  Stack.eq(frameType2),
  (!Stack.any())*
}
*/

<< 
import (
  . "github.com/katydid/katydid/lang/ast"
  "github.com/katydid/katydid/expr/ast"
  "github.com/katydid/katydid/types"
  "github.com/katydid/katydid/lang/token"
)

func newString(v interface{}) string {
  t := v.(*token.Token)
  return string(t.Lit)
}

>>

Grammar
  : PatternDecls       << &Grammar{$0.([]*PatternDecl), nil}, nil >>
  | PatternDecls Space << &Grammar{$0.([]*PatternDecl), $1.(*expr.Space)}, nil >>
  ;

PatternDecls
  : PatternDecl               << []*PatternDecl{$0.(*PatternDecl)}, nil >>
  | PatternDecls PatternDecl  << append($0.([]*PatternDecl), $1.(*PatternDecl)), nil >>
  ;

PatternDecl
  : Space id Equal Pattern
  <<
    &PatternDecl{
      Before: $0.(*expr.Space),
      Name: newString($1),
      Equal: $2.(*expr.Keyword),
      Pattern: $3.(*Pattern),
    }, nil
  >>
  | id Equal Pattern
  <<
    &PatternDecl{
      Name: newString($0),
      Equal: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
    }, nil
  >>
  ;

/*
data Pattern = Empty
| EmptySet
| TreeNode String Pattern -- New
| LeafNode (String -> Bool) -- ”Old” 
| Concat Pattern Pattern
| Or Pattern Pattern
| And Pattern Pattern
| ZeroOrMore Pattern
| Not Pattern
| Interleave Pattern Pattern -- New 
| Reference String -- New
*/

Pattern
  : Space "Empty"     << &Pattern{Empty: &Empty{$0.(*expr.Space)}}, nil >>
  | "Empty"     << &Pattern{Empty: &Empty{}}, nil >>
  | Space "EmptySet"  << &Pattern{EmptySet: &EmptySet{$0.(*expr.Space)}}, nil >>
  | "EmptySet"  << &Pattern{EmptySet: &EmptySet{}}, nil >>
  | Space "TreeNode" OpenParen Expr Comma Pattern CloseParen <<
    &Pattern{TreeNode: &TreeNode{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Name: $3.(*expr.Expr),
      Comma: $4.(*expr.Keyword),
      Pattern: $5.(*Pattern),
      CloseParen: $6.(*expr.Keyword),
    }}, nil
  >>
  | "TreeNode" OpenParen Expr Comma Pattern CloseParen <<
    &Pattern{TreeNode: &TreeNode{
      OpenParen: $1.(*expr.Keyword),
      Name: $2.(*expr.Expr),
      Comma: $3.(*expr.Keyword),
      Pattern: $4.(*Pattern),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  | Space "LeafNode" OpenParen Expr CloseParen <<
    &Pattern{LeafNode: &LeafNode{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Expr: $3.(*expr.Expr),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | "LeafNode" OpenParen Expr CloseParen <<
    &Pattern{LeafNode: &LeafNode{
      OpenParen: $1.(*expr.Keyword),
      Expr: $2.(*expr.Expr),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | Space "Concat" OpenParen Pattern Comma Pattern CloseParen <<
    &Pattern{Concat: &Concat{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      LeftPattern: $3.(*Pattern),
      Comma: $4.(*expr.Keyword),
      RightPattern: $5.(*Pattern),
      CloseParen: $6.(*expr.Keyword),
    }}, nil
  >>
  | "Concat" OpenParen Pattern Comma Pattern CloseParen <<
    &Pattern{Concat: &Concat{
      OpenParen: $1.(*expr.Keyword),
      LeftPattern: $2.(*Pattern),
      Comma: $3.(*expr.Keyword),
      RightPattern: $4.(*Pattern),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  | Space "Or" OpenParen Pattern Comma Pattern CloseParen <<
    &Pattern{Or: &Or{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      LeftPattern: $3.(*Pattern),
      Comma: $4.(*expr.Keyword),
      RightPattern: $5.(*Pattern),
      CloseParen: $6.(*expr.Keyword),
    }}, nil
  >>
  | "Or" OpenParen Pattern Comma Pattern CloseParen <<
    &Pattern{Or: &Or{
      OpenParen: $1.(*expr.Keyword),
      LeftPattern: $2.(*Pattern),
      Comma: $3.(*expr.Keyword),
      RightPattern: $4.(*Pattern),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  | Space "And" OpenParen Pattern Comma Pattern CloseParen <<
    &Pattern{And: &And{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      LeftPattern: $3.(*Pattern),
      Comma: $4.(*expr.Keyword),
      RightPattern: $5.(*Pattern),
      CloseParen: $6.(*expr.Keyword),
    }}, nil
  >>
  | "And" OpenParen Pattern Comma Pattern CloseParen <<
    &Pattern{And: &And{
      OpenParen: $1.(*expr.Keyword),
      LeftPattern: $2.(*Pattern),
      Comma: $3.(*expr.Keyword),
      RightPattern: $4.(*Pattern),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  | Space "ZeroOrMore" OpenParen Pattern CloseParen <<
    &Pattern{ZeroOrMore: &ZeroOrMore{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Pattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | "ZeroOrMore" OpenParen Pattern CloseParen <<
    &Pattern{ZeroOrMore: &ZeroOrMore{
      OpenParen: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | Space "Reference" OpenParen Space id CloseParen <<
    &Pattern{Reference: &Reference{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      BeforeName: $3.(*expr.Space),
      Name: newString($4),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  | "Reference" OpenParen Space id CloseParen <<
    &Pattern{Reference: &Reference{
      OpenParen: $1.(*expr.Keyword),
      BeforeName: $2.(*expr.Space),
      Name: newString($3),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | Space "Reference" OpenParen id CloseParen <<
    &Pattern{Reference: &Reference{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Name: newString($3),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | "Reference" OpenParen id CloseParen <<
    &Pattern{Reference: &Reference{
      OpenParen: $1.(*expr.Keyword),
      Name: newString($2),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | Space "Not" OpenParen Pattern CloseParen <<
    &Pattern{Not: &Not{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Pattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | "Not" OpenParen Pattern CloseParen <<
    &Pattern{Not: &Not{
      OpenParen: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  // | Interleave Pattern Pattern -- New 
  ;






Function
  : Space id OpenParen Exprs CloseParen << &expr.Function{Before: $0.(*expr.Space), Name: newString($1), OpenParen: $2.(*expr.Keyword), Params: $3.([]*expr.Expr), CloseParen: $4.(*expr.Keyword)}, nil >>
  | Space id OpenParen CloseParen << &expr.Function{Before: $0.(*expr.Space), Name: newString($1), OpenParen: $2.(*expr.Keyword), CloseParen: $3.(*expr.Keyword)}, nil >>
  | id OpenParen Exprs CloseParen << &expr.Function{Name: newString($0), OpenParen: $1.(*expr.Keyword), Params: $2.([]*expr.Expr), CloseParen: $3.(*expr.Keyword)}, nil >>
  | id OpenParen CloseParen << &expr.Function{Name: newString($0), OpenParen: $1.(*expr.Keyword), CloseParen: $2.(*expr.Keyword)}, nil >>
  ;

List
  : Space ListType OpenCurly Exprs CloseCurly << &expr.List{Before: $0.(*expr.Space), Type: $1.(types.Type), OpenCurly: $2.(*expr.Keyword), Elems: $3.([]*expr.Expr), CloseCurly: $4.(*expr.Keyword)}, nil >>
  | ListType OpenCurly Exprs CloseCurly << &expr.List{Type: $0.(types.Type), OpenCurly: $1.(*expr.Keyword), Elems: $2.([]*expr.Expr), CloseCurly: $3.(*expr.Keyword)}, nil >>
  | Space ListType OpenCurly CloseCurly << &expr.List{Before: $0.(*expr.Space), Type: $1.(types.Type), OpenCurly: $2.(*expr.Keyword), CloseCurly: $3.(*expr.Keyword)}, nil >>
  | ListType OpenCurly CloseCurly << &expr.List{Type: $0.(types.Type), OpenCurly: $1.(*expr.Keyword), CloseCurly: $2.(*expr.Keyword)}, nil >>
  ;

Exprs
  : Expr << []*expr.Expr{$0.(*expr.Expr)}, nil >>
  | Exprs Comma Expr << append($0.([]*expr.Expr), expr.SetExprComma($2, $1)), nil >>
  ;

Expr
  : SpaceTerminal << &expr.Expr{Terminal: $0.(*expr.Terminal)}, nil >>
  | Function << &expr.Expr{Function: $0.(*expr.Function)}, nil >>
  | List << &expr.Expr{List: $0.(*expr.List)}, nil >>
  ;

ListType
  : "[]bool" << types.LIST_BOOL, nil >>
  | "[]int" << types.LIST_INT, nil >>
  | "[]uint" << types.LIST_UINT, nil >>
  | "[]double" << types.LIST_DOUBLE, nil >>
  | "[]string" << types.LIST_STRING, nil >>
  | "[][]byte" << types.LIST_BYTES, nil >>
  ;

SpaceTerminal
  : Terminal << $0, nil >>
  | Space Terminal << expr.SetTerminalSpace($1, $0), nil >>
  ;

Terminal
  : Bool << expr.NewBoolTerminal(newString($0)) >>
  | int_lit << expr.NewIntTerminal(newString($0)) >>
  | uint_lit << expr.NewUintTerminal(newString($0)) >>
  | double_lit << expr.NewDoubleTerminal(newString($0)) >>
  | string_lit << expr.NewStringTerminal(newString($0)) >>
  | bytes_lit << expr.NewBytesTerminal(newString($0)) >>
  | bool_var << expr.NewVariableTerminal(types.SINGLE_BOOL) >>
  | int_var << expr.NewVariableTerminal(types.SINGLE_INT) >>
  | uint_var << expr.NewVariableTerminal(types.SINGLE_UINT) >>
  | double_var << expr.NewVariableTerminal(types.SINGLE_DOUBLE) >>
  | string_var << expr.NewVariableTerminal(types.SINGLE_STRING) >>
  | bytes_var << expr.NewVariableTerminal(types.SINGLE_BYTES) >>
  ;

Bool
  : "true" << true, nil >>
  | "false" << false, nil >>
  ;
Equal
  : "="  << &expr.Keyword{Value: "="}, nil >>
  | Space "=" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "=",
    }, nil
  >>
  ;

OpenParen
  : "(" << &expr.Keyword{Value: "("}, nil >>
  | Space "(" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "(",
    }, nil
  >>
  ;

CloseParen
  : ")" << &expr.Keyword{Value: ")"}, nil >>
  | Space ")" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: ")",
    }, nil
  >>
  ;

OpenCurly
  : "{" << &expr.Keyword{Value: "{"}, nil >>
  | Space "{" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "{",
    }, nil
  >>
  ;

CloseCurly
  : "}" << &expr.Keyword{Value: "}"}, nil >>
  | Space "}" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "}",
    }, nil
  >>
  ;

Comma
  : "," << &expr.Keyword{Value: ","}, nil >>
  | Space "," << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: ",",
    }, nil
  >>
  ;

Space
  : Space space << expr.AppendSpace($0, newString($1)), nil >>
  | space << &expr.Space{Space: []string{newString($0)}}, nil >>
  ;
