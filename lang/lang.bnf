<< 
import (
  . "github.com/katydid/katydid/lang/ast"
  "github.com/katydid/katydid/expr/ast"
  "github.com/katydid/katydid/types"
  "github.com/katydid/katydid/lang/token"
)

func newString(v interface{}) string {
  t := v.(*token.Token)
  return string(t.Lit)
}

>>

Grammar
  : PatternDecls       << &Grammar{$0.([]*PatternDecl), nil}, nil >>
  | PatternDecls Space << &Grammar{$0.([]*PatternDecl), $1.(*expr.Space)}, nil >>
  ;

PatternDecls
  : PatternDecl               << []*PatternDecl{$0.(*PatternDecl)}, nil >>
  | PatternDecls PatternDecl  << append($0.([]*PatternDecl), $1.(*PatternDecl)), nil >>
  ;

PatternDecl
  : Space id Equal Pattern
  <<
    &PatternDecl{
      Before: $0.(*expr.Space),
      Name: newString($1),
      Equal: $2.(*expr.Keyword),
      Pattern: $3.(*Pattern),
    }, nil
  >>
  | id Equal Pattern
  <<
    &PatternDecl{
      Name: newString($0),
      Equal: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
    }, nil
  >>
  ;

/*
data Pattern = Empty
| EmptySet
| TreeNode String Pattern -- New
| LeafNode (String -> Bool) -- ”Old” 
| Concat Pattern Pattern
| Or Pattern Pattern
| And Pattern Pattern
| ZeroOrMore Pattern
| Not Pattern
| Interleave Pattern Pattern -- New 
| Reference String -- New
*/

Pattern
  : Space "Empty"     << &Pattern{Empty: &Empty{$0.(*expr.Space)}}, nil >>
  | "Empty"     << &Pattern{Empty: &Empty{}}, nil >>
  | Space "EmptySet"  << &Pattern{EmptySet: &EmptySet{$0.(*expr.Space)}}, nil >>
  | "EmptySet"  << &Pattern{EmptySet: &EmptySet{}}, nil >>
  | Space "TreeNode" OpenParen Expr Comma Pattern CloseParen <<
    &Pattern{TreeNode: &TreeNode{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Name: $3.(*expr.Expr),
      Comma: $4.(*expr.Keyword),
      Pattern: $5.(*Pattern),
      CloseParen: $6.(*expr.Keyword),
    }}, nil
  >>
  | "TreeNode" OpenParen Expr Comma Pattern CloseParen <<
    &Pattern{TreeNode: &TreeNode{
      OpenParen: $1.(*expr.Keyword),
      Name: $2.(*expr.Expr),
      Comma: $3.(*expr.Keyword),
      Pattern: $4.(*Pattern),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  | Space "LeafNode" OpenParen Expr CloseParen <<
    &Pattern{LeafNode: &LeafNode{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Expr: $3.(*expr.Expr),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | "LeafNode" OpenParen Expr CloseParen <<
    &Pattern{LeafNode: &LeafNode{
      OpenParen: $1.(*expr.Keyword),
      Expr: $2.(*expr.Expr),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | Space "Concat" OpenParen Pattern Comma Pattern CloseParen <<
    &Pattern{Concat: &Concat{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      LeftPattern: $3.(*Pattern),
      Comma: $4.(*expr.Keyword),
      RightPattern: $5.(*Pattern),
      CloseParen: $6.(*expr.Keyword),
    }}, nil
  >>
  | "Concat" OpenParen Pattern Comma Pattern CloseParen <<
    &Pattern{Concat: &Concat{
      OpenParen: $1.(*expr.Keyword),
      LeftPattern: $2.(*Pattern),
      Comma: $3.(*expr.Keyword),
      RightPattern: $4.(*Pattern),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  | Space "Or" OpenParen Pattern Comma Pattern CloseParen <<
    &Pattern{Or: &Or{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      LeftPattern: $3.(*Pattern),
      Comma: $4.(*expr.Keyword),
      RightPattern: $5.(*Pattern),
      CloseParen: $6.(*expr.Keyword),
    }}, nil
  >>
  | "Or" OpenParen Pattern Comma Pattern CloseParen <<
    &Pattern{Or: &Or{
      OpenParen: $1.(*expr.Keyword),
      LeftPattern: $2.(*Pattern),
      Comma: $3.(*expr.Keyword),
      RightPattern: $4.(*Pattern),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  | Space "And" OpenParen Pattern Comma Pattern CloseParen <<
    &Pattern{And: &And{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      LeftPattern: $3.(*Pattern),
      Comma: $4.(*expr.Keyword),
      RightPattern: $5.(*Pattern),
      CloseParen: $6.(*expr.Keyword),
    }}, nil
  >>
  | "And" OpenParen Pattern Comma Pattern CloseParen <<
    &Pattern{And: &And{
      OpenParen: $1.(*expr.Keyword),
      LeftPattern: $2.(*Pattern),
      Comma: $3.(*expr.Keyword),
      RightPattern: $4.(*Pattern),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  | Space "ZeroOrMore" OpenParen Pattern CloseParen <<
    &Pattern{ZeroOrMore: &ZeroOrMore{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Pattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | "ZeroOrMore" OpenParen Pattern CloseParen <<
    &Pattern{ZeroOrMore: &ZeroOrMore{
      OpenParen: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | Space "Reference" OpenParen Space id CloseParen <<
    &Pattern{Reference: &Reference{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      BeforeName: $3.(*expr.Space),
      Name: newString($4),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  | "Reference" OpenParen Space id CloseParen <<
    &Pattern{Reference: &Reference{
      OpenParen: $1.(*expr.Keyword),
      BeforeName: $2.(*expr.Space),
      Name: newString($3),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | Space "Reference" OpenParen id CloseParen <<
    &Pattern{Reference: &Reference{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Name: newString($3),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | "Reference" OpenParen id CloseParen <<
    &Pattern{Reference: &Reference{
      OpenParen: $1.(*expr.Keyword),
      Name: newString($2),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | Space "Not" OpenParen Pattern CloseParen <<
    &Pattern{Not: &Not{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Pattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | "Not" OpenParen Pattern CloseParen <<
    &Pattern{Not: &Not{
      OpenParen: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  // | Interleave Pattern Pattern -- New 
  ;





