//DO NOT EDIT
//This is generated file, see build.sh
//Sources: ../expr/license.bnf ../expr/lexer.bnf, ../expr/asm.bnf, ../expr/expr.bnf, ../expr/keyword.bnf
//  Copyright 2013 Walter Schulze
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

_lineComment : '/' '/' {.} '\n' ;

_blockComment : '/' '*' {. | '*'} '*' '/' ;

_comment : _lineComment | _blockComment ;

_ws : ' ' | '\t' | '\n' | '\r' ; //whitespace

space : _comment | _ws ;

_decimal_digit : '0' - '9' ;
_octal_digit : '0' - '7' ;
_hex_digit : '0' - '9' | 'A' - 'F' | 'a' - 'f';

_int_lit     : _decimal_lit | _octal_lit | _hex_lit ;
_decimal_lit : ( '1' - '9' ) { _decimal_digit } ;
_octal_lit   : '0' { _octal_digit } ;
_hex_lit     : '0' ( 'x' | 'X' ) _hex_digit { _hex_digit } ;

_singed_int_lit : ['-'] _int_lit ;

int_lit: _int '(' _singed_int_lit ')' ;
uint_lit: _uint '(' _int_lit ')' ;

_decimals  : _decimal_digit { _decimal_digit } ;
_exponent  : ( 'e' | 'E' ) [ '+' | '-' ] _decimals ;

_float_lit : ( _decimals '.' _decimals _exponent )
			| ( _decimals '.' ( _decimals | _exponent ) )
          	| ( _decimals _exponent )
          	| ( '.' _decimals [ _exponent ] ) 
          	;

double_lit: _double '(' ['-'] ( _float_lit | _int_lit ) ')' ;

_upcase : 'A'-'Z' ;
_lowcase : 'a'-'z' ;
_id_char : _upcase | _lowcase | '_' | _decimal_digit ;

_id : (_upcase | _lowcase | '_' ) {_id_char} ;
id : _id ;

_double : 'd' 'o' 'u' 'b' 'l' 'e' ;
_int : 'i' 'n' 't';
_uint : 'u' 'i' 'n' 't';
_bytes : '[' ']' 'b' 'y' 't' 'e' ;
_string : 's' 't' 'r' 'i' 'n' 'g' ;
_bool : 'b' 'o' 'o' 'l' ;

_qualid : _id { '.' _id } ;

double_var : '$' _double ;
int_var : '$' _int ;
uint_var : '$' _uint ;
bytes_var : '$' _bytes ;
string_var : '$' _string ;
bool_var : '$' _bool ;

_big_u_value      : '\\' 'U' _hex_digit _hex_digit _hex_digit _hex_digit
                            _hex_digit _hex_digit _hex_digit _hex_digit ;
_little_u_value   : '\\' 'u' _hex_digit _hex_digit _hex_digit _hex_digit ;
_hex_byte_u_value   : '\\' 'x' _hex_digit _hex_digit ;

_octal_byte_u_value : '\\' _octal_digit _octal_digit _octal_digit ;
_byte_value       : _octal_byte_u_value | _hex_byte_u_value ;
_raw_string : '`' {.} '`' ;
_escaped_char     : '\\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '\'' | '"' ) ;
_unicode_value    : . | _little_u_value | _big_u_value | _escaped_char ;
_interpreted_string : '"' { _unicode_value | _byte_value } '"' ;

string_lit : _raw_string | _interpreted_string ;

_char_lit	: '\'' (_unicode_value | _byte_value) '\'' ;

_byte_elem : _int_lit | _char_lit ;

bytes_lit : _bytes '{' { _ws } [ _byte_elem { { _ws } ',' { _ws } _byte_elem } ] { _ws } '}' ;

<< 
import (
	. "github.com/katydid/katydid/asm/ast"
	"github.com/katydid/katydid/asm/token"
	"github.com/katydid/katydid/types"
	"github.com/katydid/katydid/expr/ast"
)

func newString(v interface{}) string {
  t := v.(*token.Token)
  return string(t.Lit)
}

>>

AllRules
	: Rules Space << $0.(*Rules).SetSpace($1.(*expr.Space)), nil >>
	| Rules << $0, nil >>
	;

Rules
	: Rules Rule  << AppendRule($0, $1) >>
	| Rule << NewRule($0) >>
	;

Rule
	: Root
	| Init
	| Final
	| Transition
	| FunctionDecl
	;

Root
	: Space "root" Equal Space id "." id << &Root{Before: $0.(*expr.Space), Equal: $2.(*expr.Keyword), BeforeQualId: $3.(*expr.Space), Package: newString($4), Message: newString($6)}, nil >>
	| "root" Equal Space id "." id << &Root{Equal: $1.(*expr.Keyword), BeforeQualId: $2.(*expr.Space), Package: newString($3), Message: newString($5)}, nil >>
	| Space "root" Equal id "." id << &Root{Before: $0.(*expr.Space), Equal: $2.(*expr.Keyword), Package: newString($3), Message: newString($5)}, nil >>
	| "root" Equal id "." id << &Root{Equal: $1.(*expr.Keyword), Package: newString($2), Message: newString($4)}, nil >>
	;

Init : Space "init" Equal Space id << &Init{
		Before: $0.(*expr.Space), 
		Equal: $2.(*expr.Keyword),
		BeforeState: $3.(*expr.Space),
		State: newString($4),
	  }, nil >>
	 | "init" Equal Space id << &Init{
		Equal: $1.(*expr.Keyword),
		BeforeState: $2.(*expr.Space),
		State: newString($3),
	  }, nil >>
	 | Space "init" Equal id << &Init{
		Before: $0.(*expr.Space), 
		Equal: $2.(*expr.Keyword),
		State: newString($3),
	  }, nil >>
	 | "init" Equal id << &Init{
		Equal: $1.(*expr.Keyword),
		State: newString($2),
	  }, nil >>
	 ;

Final : Space "final" Equal Space id << &Final{
		Before: $0.(*expr.Space), 
		Equal: $2.(*expr.Keyword),
		BeforeState: $3.(*expr.Space),
		State: newString($4),
	  }, nil >>
	| "final" Equal Space id << &Final{
		Equal: $1.(*expr.Keyword),
		BeforeState: $2.(*expr.Space),
		State: newString($3),
	  }, nil >>
	| Space "final" Equal id << &Final{
		Before: $0.(*expr.Space), 
		Equal: $2.(*expr.Keyword),
		State: newString($3),
	  }, nil >>
	| "final" Equal id << &Final{
		Equal: $1.(*expr.Keyword),
		State: newString($2),
	  }, nil >>
	;

Transition
	: Space id Space id Equal Destination
	<< &Transition{
		Before: $0.(*expr.Space),
		Src: newString($1),
		BeforeInput: $2.(*expr.Space),
		Input: newString($3),
		Equal: $4.(*expr.Keyword),
		Dst: $5.(*Destination),
	}, nil >>
	| id Space id Equal Destination
	<< &Transition{
		Src: newString($0),
		BeforeInput: $1.(*expr.Space),
		Input: newString($2),
		Equal: $3.(*expr.Keyword),
		Dst: $4.(*Destination),
	}, nil >>
	| Space id id Equal Destination
	<< &Transition{
		Before: $0.(*expr.Space),
		Src: newString($1),
		Input: newString($2),
		Equal: $3.(*expr.Keyword),
		Dst: $4.(*Destination),
	}, nil >>
	| id id Equal Destination
	<< &Transition{
		Src: newString($0),
		Input: newString($1),
		Equal: $2.(*expr.Keyword),
		Dst: $3.(*Destination),
	}, nil >>
	;

Destination
	: OpenParen Space id Comma Space id Comma Space id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		BeforeChild: $1.(*expr.Space),
		Child: newString($2),
		CommaOne: $3.(*expr.Keyword),
		BeforeSuccess: $4.(*expr.Space),
		Success: newString($5),
		CommaTwo: $6.(*expr.Keyword),
		BeforeFailure: $7.(*expr.Space),
		Failure: newString($8),
		CloseParen: $9.(*expr.Keyword),
	}, nil >>
	| OpenParen id Comma Space id Comma Space id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		Child: newString($1),
		CommaOne: $2.(*expr.Keyword),
		BeforeSuccess: $3.(*expr.Space),
		Success: newString($4),
		CommaTwo: $5.(*expr.Keyword),
		BeforeFailure: $6.(*expr.Space),
		Failure: newString($7),
		CloseParen: $8.(*expr.Keyword),
	}, nil >>
	| OpenParen Space id Comma id Comma Space id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		BeforeChild: $1.(*expr.Space),
		Child: newString($2),
		CommaOne: $3.(*expr.Keyword),
		Success: newString($4),
		CommaTwo: $5.(*expr.Keyword),
		BeforeFailure: $6.(*expr.Space),
		Failure: newString($7),
		CloseParen: $8.(*expr.Keyword),
	}, nil >>
	| OpenParen Space id Comma Space id Comma id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		BeforeChild: $1.(*expr.Space),
		Child: newString($2),
		CommaOne: $3.(*expr.Keyword),
		BeforeSuccess: $4.(*expr.Space),
		Success: newString($5),
		CommaTwo: $6.(*expr.Keyword),
		Failure: newString($7),
		CloseParen: $8.(*expr.Keyword),
	}, nil >>
	| OpenParen id Comma id Comma Space id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		Child: newString($1),
		CommaOne: $2.(*expr.Keyword),
		Success: newString($3),
		CommaTwo: $4.(*expr.Keyword),
		BeforeFailure: $5.(*expr.Space),
		Failure: newString($6),
		CloseParen: $7.(*expr.Keyword),
	}, nil >>
	| OpenParen id Comma Space id Comma id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		Child: newString($1),
		CommaOne: $2.(*expr.Keyword),
		BeforeSuccess: $3.(*expr.Space),
		Success: newString($4),
		CommaTwo: $5.(*expr.Keyword),
		Failure: newString($6),
		CloseParen: $7.(*expr.Keyword),
	}, nil >>
	| OpenParen id Comma id Comma id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		Child: newString($1),
		CommaOne: $2.(*expr.Keyword),
		Success: newString($3),
		CommaTwo: $4.(*expr.Keyword),
		Failure: newString($5),
		CloseParen: $6.(*expr.Keyword),
	}, nil >>
	| OpenParen id Comma id Comma Space id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		Child: newString($1),
		CommaOne: $2.(*expr.Keyword),
		Success: newString($3),
		CommaTwo: $4.(*expr.Keyword),
		BeforeFailure: $5.(*expr.Space),
		Failure: newString($6),
		CloseParen: $7.(*expr.Keyword),
	}, nil >>
	| OpenParen Space id Comma id Comma id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		BeforeChild: $1.(*expr.Space),
		Child: newString($2),
		CommaOne: $3.(*expr.Keyword),
		Success: newString($4),
		CommaTwo: $5.(*expr.Keyword),
		Failure: newString($6),
		CloseParen: $7.(*expr.Keyword),
	}, nil >>
	;

FunctionDecl
	: Space "func" Space id Equal Function << &FunctionDecl{
		Before: $0.(*expr.Space),
		BeforeName: $2.(*expr.Space),
		Name: newString($3),
		Equal: $4.(*expr.Keyword),
		Function: $5.(*expr.Function),
	}, nil >>
	| "func" Space id Equal Function << &FunctionDecl{
		BeforeName: $1.(*expr.Space),
		Name: newString($2),
		Equal: $3.(*expr.Keyword),
		Function: $4.(*expr.Function),
	}, nil >>
	| Space "func" id Equal Function << &FunctionDecl{
		Before: $0.(*expr.Space),
		Name: newString($2),
		Equal: $3.(*expr.Keyword),
		Function: $4.(*expr.Function),
	}, nil >>
	| "func" id Equal Function << &FunctionDecl{
		Name: newString($1),
		Equal: $2.(*expr.Keyword),
		Function: $3.(*expr.Function),
	}, nil >>
	;	
Expr
  : SpaceTerminal << &expr.Expr{Terminal: $0.(*expr.Terminal)}, nil >>
  | Function << &expr.Expr{Function: $0.(*expr.Function)}, nil >>
  | List << &expr.Expr{List: $0.(*expr.List)}, nil >>
  ;

Function
  : Space id OpenParen Exprs CloseParen << &expr.Function{Before: $0.(*expr.Space), Name: newString($1), OpenParen: $2.(*expr.Keyword), Params: $3.([]*expr.Expr), CloseParen: $4.(*expr.Keyword)}, nil >>
  | Space id OpenParen CloseParen << &expr.Function{Before: $0.(*expr.Space), Name: newString($1), OpenParen: $2.(*expr.Keyword), CloseParen: $3.(*expr.Keyword)}, nil >>
  | id OpenParen Exprs CloseParen << &expr.Function{Name: newString($0), OpenParen: $1.(*expr.Keyword), Params: $2.([]*expr.Expr), CloseParen: $3.(*expr.Keyword)}, nil >>
  | id OpenParen CloseParen << &expr.Function{Name: newString($0), OpenParen: $1.(*expr.Keyword), CloseParen: $2.(*expr.Keyword)}, nil >>
  ;

List
  : Space ListType OpenCurly Exprs CloseCurly << &expr.List{Before: $0.(*expr.Space), Type: $1.(types.Type), OpenCurly: $2.(*expr.Keyword), Elems: $3.([]*expr.Expr), CloseCurly: $4.(*expr.Keyword)}, nil >>
  | ListType OpenCurly Exprs CloseCurly << &expr.List{Type: $0.(types.Type), OpenCurly: $1.(*expr.Keyword), Elems: $2.([]*expr.Expr), CloseCurly: $3.(*expr.Keyword)}, nil >>
  | Space ListType OpenCurly CloseCurly << &expr.List{Before: $0.(*expr.Space), Type: $1.(types.Type), OpenCurly: $2.(*expr.Keyword), CloseCurly: $3.(*expr.Keyword)}, nil >>
  | ListType OpenCurly CloseCurly << &expr.List{Type: $0.(types.Type), OpenCurly: $1.(*expr.Keyword), CloseCurly: $2.(*expr.Keyword)}, nil >>
  ;

Exprs
  : Expr << []*expr.Expr{$0.(*expr.Expr)}, nil >>
  | Exprs Comma Expr << append($0.([]*expr.Expr), expr.SetExprComma($2, $1)), nil >>
  ;

ListType
  : "[]bool" << types.LIST_BOOL, nil >>
  | "[]int" << types.LIST_INT, nil >>
  | "[]uint" << types.LIST_UINT, nil >>
  | "[]double" << types.LIST_DOUBLE, nil >>
  | "[]string" << types.LIST_STRING, nil >>
  | "[][]byte" << types.LIST_BYTES, nil >>
  ;

SpaceTerminal
  : Terminal << $0, nil >>
  | Space Terminal << expr.SetTerminalSpace($1, $0), nil >>
  ;

Terminal
  : Bool << expr.NewBoolTerminal(newString($0)) >>
  | int_lit << expr.NewIntTerminal(newString($0)) >>
  | uint_lit << expr.NewUintTerminal(newString($0)) >>
  | double_lit << expr.NewDoubleTerminal(newString($0)) >>
  | string_lit << expr.NewStringTerminal(newString($0)) >>
  | bytes_lit << expr.NewBytesTerminal(newString($0)) >>
  | bool_var << expr.NewVariableTerminal(types.SINGLE_BOOL) >>
  | int_var << expr.NewVariableTerminal(types.SINGLE_INT) >>
  | uint_var << expr.NewVariableTerminal(types.SINGLE_UINT) >>
  | double_var << expr.NewVariableTerminal(types.SINGLE_DOUBLE) >>
  | string_var << expr.NewVariableTerminal(types.SINGLE_STRING) >>
  | bytes_var << expr.NewVariableTerminal(types.SINGLE_BYTES) >>
  ;

Bool
  : "true" << true, nil >>
  | "false" << false, nil >>
  ;
Equal
  : "="  << &expr.Keyword{Value: "="}, nil >>
  | Space "=" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "=",
    }, nil
  >>
  ;

OpenParen
  : "(" << &expr.Keyword{Value: "("}, nil >>
  | Space "(" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "(",
    }, nil
  >>
  ;

CloseParen
  : ")" << &expr.Keyword{Value: ")"}, nil >>
  | Space ")" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: ")",
    }, nil
  >>
  ;

OpenCurly
  : "{" << &expr.Keyword{Value: "{"}, nil >>
  | Space "{" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "{",
    }, nil
  >>
  ;

CloseCurly
  : "}" << &expr.Keyword{Value: "}"}, nil >>
  | Space "}" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "}",
    }, nil
  >>
  ;

Comma
  : "," << &expr.Keyword{Value: ","}, nil >>
  | Space "," << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: ",",
    }, nil
  >>
  ;

Space
  : Space space << expr.AppendSpace($0, newString($1)), nil >>
  | space << &expr.Space{Space: []string{newString($0)}}, nil >>
  ;
