// Code generated by protoc-gen-gogo.
// source: asm.proto
// DO NOT EDIT!

/*
Package asm is a generated protocol buffer package.

It is generated from these files:
	asm.proto

It has these top-level messages:
	Rules
	Rule
	Root
	Init
	Final
	Transition
	Destination
	FunctionDecl
*/
package asm

import proto "github.com/gogo/protobuf/proto"
import math "math"

// discarding unused import gogoproto "github.com/gogo/protobuf/gogoproto/gogo.pb"
import expr "github.com/katydid/katydid/expr/ast"

import fmt "fmt"
import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type Rules struct {
	Rules            []*Rule     `protobuf:"bytes,1,rep" json:"Rules,omitempty"`
	Final            *expr.Space `protobuf:"bytes,2,opt" json:"Final,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Rules) Reset()      { *m = Rules{} }
func (*Rules) ProtoMessage() {}

func (m *Rules) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *Rules) GetFinal() *expr.Space {
	if m != nil {
		return m.Final
	}
	return nil
}

type Rule struct {
	Root             *Root         `protobuf:"bytes,1,opt" json:"Root,omitempty"`
	Init             *Init         `protobuf:"bytes,2,opt" json:"Init,omitempty"`
	Final            *Final        `protobuf:"bytes,3,opt" json:"Final,omitempty"`
	Transition       *Transition   `protobuf:"bytes,4,opt" json:"Transition,omitempty"`
	FunctionDecl     *FunctionDecl `protobuf:"bytes,5,opt" json:"FunctionDecl,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Rule) Reset()      { *m = Rule{} }
func (*Rule) ProtoMessage() {}

func (m *Rule) GetRoot() *Root {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *Rule) GetInit() *Init {
	if m != nil {
		return m.Init
	}
	return nil
}

func (m *Rule) GetFinal() *Final {
	if m != nil {
		return m.Final
	}
	return nil
}

func (m *Rule) GetTransition() *Transition {
	if m != nil {
		return m.Transition
	}
	return nil
}

func (m *Rule) GetFunctionDecl() *FunctionDecl {
	if m != nil {
		return m.FunctionDecl
	}
	return nil
}

type Root struct {
	Before           *expr.Space   `protobuf:"bytes,1,opt" json:"Before,omitempty"`
	Equal            *expr.Keyword `protobuf:"bytes,2,opt" json:"Equal,omitempty"`
	BeforeQualId     *expr.Space   `protobuf:"bytes,3,opt" json:"BeforeQualId,omitempty"`
	Package          string        `protobuf:"bytes,4,opt" json:"Package"`
	Message          string        `protobuf:"bytes,5,opt" json:"Message"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Root) Reset()      { *m = Root{} }
func (*Root) ProtoMessage() {}

func (m *Root) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Root) GetEqual() *expr.Keyword {
	if m != nil {
		return m.Equal
	}
	return nil
}

func (m *Root) GetBeforeQualId() *expr.Space {
	if m != nil {
		return m.BeforeQualId
	}
	return nil
}

func (m *Root) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *Root) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type Init struct {
	Before           *expr.Space   `protobuf:"bytes,1,opt" json:"Before,omitempty"`
	Equal            *expr.Keyword `protobuf:"bytes,2,opt" json:"Equal,omitempty"`
	BeforeState      *expr.Space   `protobuf:"bytes,3,opt" json:"BeforeState,omitempty"`
	State            string        `protobuf:"bytes,4,opt" json:"State"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Init) Reset()      { *m = Init{} }
func (*Init) ProtoMessage() {}

func (m *Init) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Init) GetEqual() *expr.Keyword {
	if m != nil {
		return m.Equal
	}
	return nil
}

func (m *Init) GetBeforeState() *expr.Space {
	if m != nil {
		return m.BeforeState
	}
	return nil
}

func (m *Init) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

type Final struct {
	Before           *expr.Space   `protobuf:"bytes,1,opt" json:"Before,omitempty"`
	Equal            *expr.Keyword `protobuf:"bytes,2,opt" json:"Equal,omitempty"`
	BeforeState      *expr.Space   `protobuf:"bytes,3,opt" json:"BeforeState,omitempty"`
	State            string        `protobuf:"bytes,4,opt" json:"State"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Final) Reset()      { *m = Final{} }
func (*Final) ProtoMessage() {}

func (m *Final) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Final) GetEqual() *expr.Keyword {
	if m != nil {
		return m.Equal
	}
	return nil
}

func (m *Final) GetBeforeState() *expr.Space {
	if m != nil {
		return m.BeforeState
	}
	return nil
}

func (m *Final) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

type Transition struct {
	Before           *expr.Space   `protobuf:"bytes,1,opt" json:"Before,omitempty"`
	Src              string        `protobuf:"bytes,2,opt" json:"Src"`
	BeforeInput      *expr.Space   `protobuf:"bytes,3,opt" json:"BeforeInput,omitempty"`
	Input            string        `protobuf:"bytes,4,opt" json:"Input"`
	Equal            *expr.Keyword `protobuf:"bytes,5,opt" json:"Equal,omitempty"`
	Dst              *Destination  `protobuf:"bytes,6,opt" json:"Dst,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Transition) Reset()      { *m = Transition{} }
func (*Transition) ProtoMessage() {}

func (m *Transition) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Transition) GetSrc() string {
	if m != nil {
		return m.Src
	}
	return ""
}

func (m *Transition) GetBeforeInput() *expr.Space {
	if m != nil {
		return m.BeforeInput
	}
	return nil
}

func (m *Transition) GetInput() string {
	if m != nil {
		return m.Input
	}
	return ""
}

func (m *Transition) GetEqual() *expr.Keyword {
	if m != nil {
		return m.Equal
	}
	return nil
}

func (m *Transition) GetDst() *Destination {
	if m != nil {
		return m.Dst
	}
	return nil
}

type Destination struct {
	OpenParen        *expr.Keyword `protobuf:"bytes,1,opt" json:"OpenParen,omitempty"`
	BeforeChild      *expr.Space   `protobuf:"bytes,2,opt" json:"BeforeChild,omitempty"`
	Child            string        `protobuf:"bytes,3,opt" json:"Child"`
	CommaOne         *expr.Keyword `protobuf:"bytes,4,opt" json:"CommaOne,omitempty"`
	BeforeSuccess    *expr.Space   `protobuf:"bytes,5,opt" json:"BeforeSuccess,omitempty"`
	Success          string        `protobuf:"bytes,6,opt" json:"Success"`
	CommaTwo         *expr.Keyword `protobuf:"bytes,7,opt" json:"CommaTwo,omitempty"`
	BeforeFailure    *expr.Space   `protobuf:"bytes,8,opt" json:"BeforeFailure,omitempty"`
	Failure          string        `protobuf:"bytes,9,opt" json:"Failure"`
	CloseParen       *expr.Keyword `protobuf:"bytes,10,opt" json:"CloseParen,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *Destination) Reset()      { *m = Destination{} }
func (*Destination) ProtoMessage() {}

func (m *Destination) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Destination) GetBeforeChild() *expr.Space {
	if m != nil {
		return m.BeforeChild
	}
	return nil
}

func (m *Destination) GetChild() string {
	if m != nil {
		return m.Child
	}
	return ""
}

func (m *Destination) GetCommaOne() *expr.Keyword {
	if m != nil {
		return m.CommaOne
	}
	return nil
}

func (m *Destination) GetBeforeSuccess() *expr.Space {
	if m != nil {
		return m.BeforeSuccess
	}
	return nil
}

func (m *Destination) GetSuccess() string {
	if m != nil {
		return m.Success
	}
	return ""
}

func (m *Destination) GetCommaTwo() *expr.Keyword {
	if m != nil {
		return m.CommaTwo
	}
	return nil
}

func (m *Destination) GetBeforeFailure() *expr.Space {
	if m != nil {
		return m.BeforeFailure
	}
	return nil
}

func (m *Destination) GetFailure() string {
	if m != nil {
		return m.Failure
	}
	return ""
}

func (m *Destination) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type FunctionDecl struct {
	Before           *expr.Space    `protobuf:"bytes,1,opt" json:"Before,omitempty"`
	BeforeName       *expr.Space    `protobuf:"bytes,2,opt" json:"BeforeName,omitempty"`
	Name             string         `protobuf:"bytes,3,opt" json:"Name"`
	Equal            *expr.Keyword  `protobuf:"bytes,4,opt" json:"Equal,omitempty"`
	BeforeFunc       *expr.Space    `protobuf:"bytes,5,opt" json:"BeforeFunc,omitempty"`
	Function         *expr.Function `protobuf:"bytes,6,opt" json:"Function,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *FunctionDecl) Reset()      { *m = FunctionDecl{} }
func (*FunctionDecl) ProtoMessage() {}

func (m *FunctionDecl) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *FunctionDecl) GetBeforeName() *expr.Space {
	if m != nil {
		return m.BeforeName
	}
	return nil
}

func (m *FunctionDecl) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FunctionDecl) GetEqual() *expr.Keyword {
	if m != nil {
		return m.Equal
	}
	return nil
}

func (m *FunctionDecl) GetBeforeFunc() *expr.Space {
	if m != nil {
		return m.BeforeFunc
	}
	return nil
}

func (m *FunctionDecl) GetFunction() *expr.Function {
	if m != nil {
		return m.Function
	}
	return nil
}

func init() {
}
func (this *Rules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&asm.Rules{` +
		`Rules:` + fmt.Sprintf("%#v", this.Rules),
		`Final:` + fmt.Sprintf("%#v", this.Final),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *Rule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&asm.Rule{` +
		`Root:` + fmt.Sprintf("%#v", this.Root),
		`Init:` + fmt.Sprintf("%#v", this.Init),
		`Final:` + fmt.Sprintf("%#v", this.Final),
		`Transition:` + fmt.Sprintf("%#v", this.Transition),
		`FunctionDecl:` + fmt.Sprintf("%#v", this.FunctionDecl),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *Root) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&asm.Root{` +
		`Before:` + fmt.Sprintf("%#v", this.Before),
		`Equal:` + fmt.Sprintf("%#v", this.Equal),
		`BeforeQualId:` + fmt.Sprintf("%#v", this.BeforeQualId),
		`Package:` + fmt.Sprintf("%#v", this.Package),
		`Message:` + fmt.Sprintf("%#v", this.Message),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *Init) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&asm.Init{` +
		`Before:` + fmt.Sprintf("%#v", this.Before),
		`Equal:` + fmt.Sprintf("%#v", this.Equal),
		`BeforeState:` + fmt.Sprintf("%#v", this.BeforeState),
		`State:` + fmt.Sprintf("%#v", this.State),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *Final) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&asm.Final{` +
		`Before:` + fmt.Sprintf("%#v", this.Before),
		`Equal:` + fmt.Sprintf("%#v", this.Equal),
		`BeforeState:` + fmt.Sprintf("%#v", this.BeforeState),
		`State:` + fmt.Sprintf("%#v", this.State),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *Transition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&asm.Transition{` +
		`Before:` + fmt.Sprintf("%#v", this.Before),
		`Src:` + fmt.Sprintf("%#v", this.Src),
		`BeforeInput:` + fmt.Sprintf("%#v", this.BeforeInput),
		`Input:` + fmt.Sprintf("%#v", this.Input),
		`Equal:` + fmt.Sprintf("%#v", this.Equal),
		`Dst:` + fmt.Sprintf("%#v", this.Dst),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *Destination) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&asm.Destination{` +
		`OpenParen:` + fmt.Sprintf("%#v", this.OpenParen),
		`BeforeChild:` + fmt.Sprintf("%#v", this.BeforeChild),
		`Child:` + fmt.Sprintf("%#v", this.Child),
		`CommaOne:` + fmt.Sprintf("%#v", this.CommaOne),
		`BeforeSuccess:` + fmt.Sprintf("%#v", this.BeforeSuccess),
		`Success:` + fmt.Sprintf("%#v", this.Success),
		`CommaTwo:` + fmt.Sprintf("%#v", this.CommaTwo),
		`BeforeFailure:` + fmt.Sprintf("%#v", this.BeforeFailure),
		`Failure:` + fmt.Sprintf("%#v", this.Failure),
		`CloseParen:` + fmt.Sprintf("%#v", this.CloseParen),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *FunctionDecl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&asm.FunctionDecl{` +
		`Before:` + fmt.Sprintf("%#v", this.Before),
		`BeforeName:` + fmt.Sprintf("%#v", this.BeforeName),
		`Name:` + fmt.Sprintf("%#v", this.Name),
		`Equal:` + fmt.Sprintf("%#v", this.Equal),
		`BeforeFunc:` + fmt.Sprintf("%#v", this.BeforeFunc),
		`Function:` + fmt.Sprintf("%#v", this.Function),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func valueToGoStringAsm(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringAsm(e map[int32]github_com_gogo_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
