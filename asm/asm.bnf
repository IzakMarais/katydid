
<< 
import (
	. "github.com/katydid/katydid/asm/ast"
	"github.com/katydid/katydid/asm/token"
	"github.com/katydid/katydid/types"
	"github.com/katydid/katydid/expr/ast"
)

func newString(v interface{}) string {
  t := v.(*token.Token)
  return string(t.Lit)
}

>>

AllRules
	: Rules Space << $0.(*Rules).SetSpace($1.(*expr.Space)), nil >>
	| Rules << $0, nil >>
	;

Rules
	: Rules Rule  << AppendRule($0, $1) >>
	| Rule << NewRule($0) >>
	;

Rule
	: Root
	| Init
	| Final
	| Transition
	| FunctionDecl
	;

Root
	: Space "root" Equal Space id "." id << &Root{Before: $0.(*expr.Space), Eq: $2.(*expr.Keyword), BeforeQualId: $3.(*expr.Space), Package: newString($4), Message: newString($6)}, nil >>
	| "root" Equal Space id "." id << &Root{Eq: $1.(*expr.Keyword), BeforeQualId: $2.(*expr.Space), Package: newString($3), Message: newString($5)}, nil >>
	| Space "root" Equal id "." id << &Root{Before: $0.(*expr.Space), Eq: $2.(*expr.Keyword), Package: newString($3), Message: newString($5)}, nil >>
	| "root" Equal id "." id << &Root{Eq: $1.(*expr.Keyword), Package: newString($2), Message: newString($4)}, nil >>
	;

Init : Space "init" Equal Space id << &Init{
		Before: $0.(*expr.Space), 
		Eq: $2.(*expr.Keyword),
		BeforeState: $3.(*expr.Space),
		State: newString($4),
	  }, nil >>
	 | "init" Equal Space id << &Init{
		Eq: $1.(*expr.Keyword),
		BeforeState: $2.(*expr.Space),
		State: newString($3),
	  }, nil >>
	 | Space "init" Equal id << &Init{
		Before: $0.(*expr.Space), 
		Eq: $2.(*expr.Keyword),
		State: newString($3),
	  }, nil >>
	 | "init" Equal id << &Init{
		Eq: $1.(*expr.Keyword),
		State: newString($2),
	  }, nil >>
	 ;

Final : Space "final" Equal Space id << &Final{
		Before: $0.(*expr.Space), 
		Eq: $2.(*expr.Keyword),
		BeforeState: $3.(*expr.Space),
		State: newString($4),
	  }, nil >>
	| "final" Equal Space id << &Final{
		Eq: $1.(*expr.Keyword),
		BeforeState: $2.(*expr.Space),
		State: newString($3),
	  }, nil >>
	| Space "final" Equal id << &Final{
		Before: $0.(*expr.Space), 
		Eq: $2.(*expr.Keyword),
		State: newString($3),
	  }, nil >>
	| "final" Equal id << &Final{
		Eq: $1.(*expr.Keyword),
		State: newString($2),
	  }, nil >>
	;

Transition
	: Space id Space id Equal Destination
	<< &Transition{
		Before: $0.(*expr.Space),
		Src: newString($1),
		BeforeInput: $2.(*expr.Space),
		Input: newString($3),
		Eq: $4.(*expr.Keyword),
		Dst: $5.(*Destination),
	}, nil >>
	| id Space id Equal Destination
	<< &Transition{
		Src: newString($0),
		BeforeInput: $1.(*expr.Space),
		Input: newString($2),
		Eq: $3.(*expr.Keyword),
		Dst: $4.(*Destination),
	}, nil >>
	| Space id id Equal Destination
	<< &Transition{
		Before: $0.(*expr.Space),
		Src: newString($1),
		Input: newString($2),
		Eq: $3.(*expr.Keyword),
		Dst: $4.(*Destination),
	}, nil >>
	| id id Equal Destination
	<< &Transition{
		Src: newString($0),
		Input: newString($1),
		Eq: $2.(*expr.Keyword),
		Dst: $3.(*Destination),
	}, nil >>
	;

Destination
	: OpenParen Space id Comma Space id Comma Space id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		BeforeChild: $1.(*expr.Space),
		Child: newString($2),
		CommaOne: $3.(*expr.Keyword),
		BeforeSuccess: $4.(*expr.Space),
		Success: newString($5),
		CommaTwo: $6.(*expr.Keyword),
		BeforeFailure: $7.(*expr.Space),
		Failure: newString($8),
		CloseParen: $9.(*expr.Keyword),
	}, nil >>
	| OpenParen id Comma Space id Comma Space id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		Child: newString($1),
		CommaOne: $2.(*expr.Keyword),
		BeforeSuccess: $3.(*expr.Space),
		Success: newString($4),
		CommaTwo: $5.(*expr.Keyword),
		BeforeFailure: $6.(*expr.Space),
		Failure: newString($7),
		CloseParen: $8.(*expr.Keyword),
	}, nil >>
	| OpenParen Space id Comma id Comma Space id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		BeforeChild: $1.(*expr.Space),
		Child: newString($2),
		CommaOne: $3.(*expr.Keyword),
		Success: newString($4),
		CommaTwo: $5.(*expr.Keyword),
		BeforeFailure: $6.(*expr.Space),
		Failure: newString($7),
		CloseParen: $8.(*expr.Keyword),
	}, nil >>
	| OpenParen Space id Comma Space id Comma id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		BeforeChild: $1.(*expr.Space),
		Child: newString($2),
		CommaOne: $3.(*expr.Keyword),
		BeforeSuccess: $4.(*expr.Space),
		Success: newString($5),
		CommaTwo: $6.(*expr.Keyword),
		Failure: newString($7),
		CloseParen: $8.(*expr.Keyword),
	}, nil >>
	| OpenParen id Comma id Comma Space id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		Child: newString($1),
		CommaOne: $2.(*expr.Keyword),
		Success: newString($3),
		CommaTwo: $4.(*expr.Keyword),
		BeforeFailure: $5.(*expr.Space),
		Failure: newString($6),
		CloseParen: $7.(*expr.Keyword),
	}, nil >>
	| OpenParen id Comma Space id Comma id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		Child: newString($1),
		CommaOne: $2.(*expr.Keyword),
		BeforeSuccess: $3.(*expr.Space),
		Success: newString($4),
		CommaTwo: $5.(*expr.Keyword),
		Failure: newString($6),
		CloseParen: $7.(*expr.Keyword),
	}, nil >>
	| OpenParen id Comma id Comma id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		Child: newString($1),
		CommaOne: $2.(*expr.Keyword),
		Success: newString($3),
		CommaTwo: $4.(*expr.Keyword),
		Failure: newString($5),
		CloseParen: $6.(*expr.Keyword),
	}, nil >>
	| OpenParen id Comma id Comma Space id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		Child: newString($1),
		CommaOne: $2.(*expr.Keyword),
		Success: newString($3),
		CommaTwo: $4.(*expr.Keyword),
		BeforeFailure: $5.(*expr.Space),
		Failure: newString($6),
		CloseParen: $7.(*expr.Keyword),
	}, nil >>
	| OpenParen Space id Comma id Comma id CloseParen
	<< &Destination{
		OpenParen: $0.(*expr.Keyword),
		BeforeChild: $1.(*expr.Space),
		Child: newString($2),
		CommaOne: $3.(*expr.Keyword),
		Success: newString($4),
		CommaTwo: $5.(*expr.Keyword),
		Failure: newString($6),
		CloseParen: $7.(*expr.Keyword),
	}, nil >>
	;

FunctionDecl
	: Space "func" Space id Equal Function << &FunctionDecl{
		Before: $0.(*expr.Space),
		BeforeName: $2.(*expr.Space),
		Name: newString($3),
		Eq: $4.(*expr.Keyword),
		Function: $5.(*expr.Function),
	}, nil >>
	| "func" Space id Equal Function << &FunctionDecl{
		BeforeName: $1.(*expr.Space),
		Name: newString($2),
		Eq: $3.(*expr.Keyword),
		Function: $4.(*expr.Function),
	}, nil >>
	| Space "func" id Equal Function << &FunctionDecl{
		Before: $0.(*expr.Space),
		Name: newString($2),
		Eq: $3.(*expr.Keyword),
		Function: $4.(*expr.Function),
	}, nil >>
	| "func" id Equal Function << &FunctionDecl{
		Name: newString($1),
		Eq: $2.(*expr.Keyword),
		Function: $3.(*expr.Function),
	}, nil >>
	;	

