//  Copyright 2013 Walter Schulze
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

/* Lexer Part */

_lineComment : '/' '/' {.} '\n' ;

_blockComment : '/' '*' {. | '*'} '*' '/' ;

!comment : _lineComment | _blockComment ;

!whitespace : ' ' | '\t' | '\n' | '\r' ;

_ws : ' ' | '\t' | '\n' | '\r' ;

_decimal_digit : '0' - '9' ;
_octal_digit : '0' - '7' ;
_hex_digit : '0' - '9' | 'A' - 'F' | 'a' - 'f';

_int_lit     : _decimal_lit | _octal_lit | _hex_lit ;
_decimal_lit : ( '1' - '9' ) { _decimal_digit } ;
_octal_lit   : '0' { _octal_digit } ;
_hex_lit     : '0' ( 'x' | 'X' ) _hex_digit { _hex_digit } ;

_singed_int_lit : ['-'] _int_lit ;

int64_lit: 'i' 'n' 't' '6' '4' '(' _singed_int_lit ')' ;
int32_lit: 'i' 'n' 't' '3' '2' '(' _singed_int_lit ')' ;
uint64_lit: 'u' 'i' 'n' 't' '6' '4' '(' _int_lit ')' ;
uint32_lit: 'u' 'i' 'n' 't' '3' '2' '(' _int_lit ')' ;

_decimals  : _decimal_digit { _decimal_digit } ;
_exponent  : ( 'e' | 'E' ) [ '+' | '-' ] _decimals ;

_float_lit : ( _decimals '.' _decimals _exponent )
			| ( _decimals '.' ( _decimals | _exponent ) )
          	| ( _decimals _exponent )
          	| ( '.' _decimals [ _exponent ] ) 
          	;

double_lit: 'd' 'o' 'u' 'b' 'l' 'e' '(' ['-'] ( _float_lit | _int_lit ) ')' ;

float_lit: 'f' 'l' 'o' 'a' 't' '(' ['-'] ( _float_lit | _int_lit ) ')' ;

_upcase : 'A'-'Z' ;
_lowcase : 'a'-'z' ;
_id_char : _upcase | _lowcase | '_' | _decimal_digit ;

id : (_upcase | _lowcase | '_' ) {_id_char} ;

_big_u_value      : '\\' 'U' _hex_digit _hex_digit _hex_digit _hex_digit
                            _hex_digit _hex_digit _hex_digit _hex_digit ;
_little_u_value   : '\\' 'u' _hex_digit _hex_digit _hex_digit _hex_digit ;
_hex_byte_u_value   : '\\' 'x' _hex_digit _hex_digit ;
_escaped_char     : '\\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '\'' | '"' ) ;

_octal_byte_u_value : '\\' _octal_digit _octal_digit _octal_digit ;
_byte_value       : _octal_byte_u_value | _hex_byte_u_value ;
_unicode_value    : . | _little_u_value | _big_u_value | _escaped_char ;
_raw_string : '`' {.} '`' ;
_interpreted_string : '"' { _unicode_value | _byte_value } '"' ;

string_lit : _raw_string | _interpreted_string ;

_char_lit	: '\'' (_unicode_value | _byte_value) '\'' ;
_byte_elem : _int_lit | _char_lit ;

bytes_lit : '[' ']' 'b' 'y' 't' 'e' '{' { _ws } [ _byte_elem { { _ws } ',' { _ws } _byte_elem } ] { _ws } '}' ;

/* Syntax Part */

<< 
import (
	"github.com/awalterschulze/katydid/asm/ast"
	"github.com/awalterschulze/katydid/types"
	"code.google.com/p/gogoprotobuf/proto"
)
>>

Rules
	: Rules Rule  << ast.AppendRule($0, $1) >>
	| Rule << ast.NewRule($0) >>
	| Expr
	;

Rule
	: Root
	| Init
	| Transition
	| IfExpr
	;

Root
	: "root" "=" id "." id << &ast.Init{Package: ast.IdToString($2), Message: ast.IdToString($4), State: "root"}, nil >>
	;

Init
	: id "." id "=" id << &ast.Init{Package: ast.IdToString($0), Message: ast.IdToString($2), State: ast.IdToString($4)}, nil >>
	;

Transition
	: id id "=" id << &ast.Transition{Src: ast.IdToString($0), Input: ast.IdToString($1), Dst: ast.IdToString($3)}, nil >>
	;

IfExpr
	: "if" Expr "then" StateExpr "else" StateExpr << &ast.IfExpr{Condition: $1.(*ast.Expr), Then: $3.(*ast.StateExpr), Else: $5.(*ast.StateExpr)}, nil >>
	;

StateExpr
	: "{" IfExpr "}" << &ast.StateExpr{IfExpr: $1.(*ast.IfExpr)}, nil >>
	| id << &ast.StateExpr{State: proto.String(ast.IdToString($0))}, nil >>
	;

Function
	: id "(" Params ")" << &ast.Function{Name: ast.IdToString($0), Params: $2.([]*ast.Expr)}, nil >>
	| id "(" ")" << &ast.Function{Name: ast.IdToString($0), Params: nil}, nil >>
	| "(" Expr Comparator Expr ")" << &ast.Function{Name: $2.(string), Params: []*ast.Expr{$1.(*ast.Expr), $3.(*ast.Expr)}}, nil >>
	;

Comparator
	: "=="  << "eq", nil >>
	| "<"   << "lt", nil >>
	| "<="  << "le", nil >>
	| ">"   << "gt", nil >>
	| ">="  << "ge", nil >>
	| "&&"  << "and", nil >>
	| "||"  << "or", nil >>
	| "or"  << "or", nil >>
	| "and" << "and", nil >>
	;

Params
	: Params "," Expr << append($0.([]*ast.Expr), $2.(*ast.Expr)), nil >>
	| Expr << []*ast.Expr{$0.(*ast.Expr)}, nil >>
	;

Expr
	: Terminal << &ast.Expr{Terminal: $0.(*ast.Terminal)}, nil >>
	| Function << &ast.Expr{Function: $0.(*ast.Function)}, nil >>
	| List << &ast.Expr{List: $0.(*ast.List)}, nil >>
	;

List
	: "{" Exprs "}" << &ast.List{Elems: $1.([]*ast.Expr)}, nil >>
	| ListType "{" Exprs "}" << &ast.List{Type: $0.(*types.Type), Elems: $2.([]*ast.Expr)}, nil >>
	| ListType "{" "}" << &ast.List{Type: $0.(*types.Type)}, nil >>
	;

Exprs
	: Expr << []*ast.Expr{$0.(*ast.Expr)}, nil >>
	| Exprs "," Expr << append($0.([]*ast.Expr), $2.(*ast.Expr)), nil >>
	;

ListType
	: "[]bool" << types.LIST_BOOL.Enum(), nil >>
	| "[]int64" << types.LIST_INT64.Enum(), nil >>
	| "[]int32" << types.LIST_INT32.Enum(), nil >>
	| "[]uint64" << types.LIST_UINT64.Enum(), nil >>
	| "[]uint32" << types.LIST_UINT32.Enum(), nil >>
	| "[]double" << types.LIST_DOUBLE.Enum(), nil >>
	| "[]float" << types.LIST_FLOAT.Enum(), nil >>
	| "[]string" << types.LIST_STRING.Enum(), nil >>
	| "[][]byte" << types.LIST_BYTES.Enum(), nil >>
	;

Terminal
	: Bool << &ast.Terminal{BoolValue: proto.Bool($0.(bool))}, nil >>
	| int64_lit << &ast.Terminal{Int64Value: ast.ToInt64(ast.Strip($0, "int64"))}, nil >>
	| int32_lit << &ast.Terminal{Int32Value: ast.ToInt32(ast.Strip($0, "int32"))}, nil >>
	| uint64_lit << &ast.Terminal{Uint64Value: ast.ToUint64(ast.Strip($0, "uint64"))}, nil >>
	| uint32_lit << &ast.Terminal{Uint32Value: ast.ToUint32(ast.Strip($0, "uint32"))}, nil >>
	| double_lit << &ast.Terminal{DoubleValue: ast.ToFloat64(ast.Strip($0, "double"))}, nil >>
	| float_lit << &ast.Terminal{FloatValue: ast.ToFloat32(ast.Strip($0, "float"))}, nil >>
	| string_lit << &ast.Terminal{StringValue: proto.String(ast.ToString($0))}, nil >>
	| bytes_lit << ast.NewBytesTerminal($0) >>
	| id "." id "." id << &ast.Terminal{Variable: &ast.Variable{Package: ast.IdToString($0), Message: ast.IdToString($2), Field: ast.IdToString($4)}}, nil >>
	;

Bool
	: "true" << true, nil >>
	| "false" << false, nil >>
	;

