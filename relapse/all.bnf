//  DO NOT EDIT
//  This is generated file, see build.sh
//  Sources: ../expr/license.bnf ../expr/lexer.bnf, import.bnf, relapse.bnf, ../expr/expr.bnf, ../expr/keyword.bnf

//  Copyright 2013 Walter Schulze
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

_lineComment : '/' '/' {.} '\n' ;

_blockComment : '/' '*' {. | '*'} '*' '/' ;

_comment : _lineComment | _blockComment ;

_ws : ' ' | '\t' | '\n' | '\r' ; //whitespace

space : _comment | _ws { _ws } ;

_decimal_digit : '0' - '9' ;
_octal_digit : '0' - '7' ;
_hex_digit : '0' - '9' | 'A' - 'F' | 'a' - 'f';

_int_lit     : _decimal_lit | _octal_lit | _hex_lit ;
_decimal_lit : ( '1' - '9' ) { _decimal_digit } ;
_octal_lit   : '0' { _octal_digit } ;
_hex_lit     : '0' ( 'x' | 'X' ) _hex_digit { _hex_digit } ;

_singed_int_lit : ['-'] _int_lit ;

int_lit: _int '(' _singed_int_lit ')' ;
uint_lit: _uint '(' _int_lit ')' ;

_decimals  : _decimal_digit { _decimal_digit } ;
_exponent  : ( 'e' | 'E' ) [ '+' | '-' ] _decimals ;

_float_lit : ( _decimals '.' _decimals _exponent )
			| ( _decimals '.' ( _decimals | _exponent ) )
          	| ( _decimals _exponent )
          	| ( '.' _decimals [ _exponent ] ) 
          	;

double_lit: _double '(' ['-'] ( _float_lit | _int_lit ) ')' ;

_upcase : 'A'-'Z' ;
_lowcase : 'a'-'z' ;
_id_char : _upcase | _lowcase | '_' | _decimal_digit ;

_id : (_upcase | _lowcase | '_' ) {_id_char} ;
id : _id ;

_double : 'd' 'o' 'u' 'b' 'l' 'e' ;
_int : 'i' 'n' 't';
_uint : 'u' 'i' 'n' 't';
_bytes : '[' ']' 'b' 'y' 't' 'e' ;
_string : 's' 't' 'r' 'i' 'n' 'g' ;
_bool : 'b' 'o' 'o' 'l' ;

_qualid : _id { '.' _id } ;

double_var : '$' _double ;
int_var : '$' _int ;
uint_var : '$' _uint ;
bytes_var : '$' _bytes ;
string_var : '$' _string ;
bool_var : '$' _bool ;

_big_u_value      : '\\' 'U' _hex_digit _hex_digit _hex_digit _hex_digit
                            _hex_digit _hex_digit _hex_digit _hex_digit ;
_little_u_value   : '\\' 'u' _hex_digit _hex_digit _hex_digit _hex_digit ;
_hex_byte_u_value   : '\\' 'x' _hex_digit _hex_digit ;

_octal_byte_u_value : '\\' _octal_digit _octal_digit _octal_digit ;
_byte_value       : _octal_byte_u_value | _hex_byte_u_value ;
_raw_string : '`' {.} '`' ;
_escaped_char     : '\\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '\'' | '"' ) ;
_unicode_value    : . | _little_u_value | _big_u_value | _escaped_char ;
_interpreted_string : '"' { _unicode_value | _byte_value } '"' ;

string_lit : _raw_string | _interpreted_string ;

_char_lit	: '\'' (_unicode_value | _byte_value) '\'' ;

_byte_elem : _int_lit | _char_lit ;

bytes_lit : _bytes '{' { _ws } [ _byte_elem { { _ws } ',' { _ws } _byte_elem } ] { _ws } '}' ;
<< 
import (
  . "github.com/katydid/katydid/relapse/ast"
  "github.com/katydid/katydid/expr/ast"
  "github.com/katydid/katydid/types"
  "github.com/katydid/katydid/relapse/token"
  "strconv"
)

func newString(v interface{}) string {
  t := v.(*token.Token)
  return string(t.Lit)
}

func unquote(s1 string) string {
  s, err := strconv.Unquote(s1)
  if err != nil {
    return s1
  }
  return s
}

>>
Grammar
  : Pattern                     << &Grammar{$0.(*Pattern), nil, nil}, nil >>  
  | Pattern Space               << &Grammar{$0.(*Pattern), nil, $1.(*expr.Space)}, nil >>
  | Pattern PatternDecls        << &Grammar{$0.(*Pattern), $1.([]*PatternDecl), nil}, nil >>
  | Pattern PatternDecls Space  << &Grammar{$0.(*Pattern), $1.([]*PatternDecl), $2.(*expr.Space)}, nil >>
  | PatternDecls                << &Grammar{nil, $0.([]*PatternDecl), nil}, nil >>
  | PatternDecls Space          << &Grammar{nil, $0.([]*PatternDecl), $1.(*expr.Space)}, nil >>
  ;

PatternDecls
  : PatternDecl               << []*PatternDecl{$0.(*PatternDecl)}, nil >>
  | PatternDecls PatternDecl  << append($0.([]*PatternDecl), $1.(*PatternDecl)), nil >>
  ;

PatternDecl
  : At Space id Equal Pattern
  <<
    &PatternDecl{
      At: $0.(*expr.Keyword),
      Before: $1.(*expr.Space),
      Name: newString($2),
      Eq: $3.(*expr.Keyword),
      Pattern: $4.(*Pattern),
    }, nil
  >>
  | At id Equal Pattern
  <<
    &PatternDecl{
      At: $0.(*expr.Keyword),
      Name: newString($1),
      Eq: $2.(*expr.Keyword),
      Pattern: $3.(*Pattern),
    }, nil
  >>
  ;

Name
  : Space string_lit <<
    &NameExpr{Name: &Name{
      Before: $0.(*expr.Space),
      Name: unquote(newString($1)),
    }}, nil
  >>
  | string_lit <<
    &NameExpr{Name: &Name{
      Name: unquote(newString($0)),
    }}, nil
  >>
  | Space id <<
    &NameExpr{Name: &Name{
      Before: $0.(*expr.Space),
      Name: newString($1),
    }}, nil
  >>
  | id <<
    &NameExpr{Name: &Name{
      Name: newString($0),
    }}, nil
  >>
  ;

NameExpr
  : Underscore   << &NameExpr{AnyName: &AnyName{$0.(*expr.Keyword)}}, nil >>
  | Name
  | Exclamation OpenParen NameExpr CloseParen <<
    &NameExpr{AnyNameExcept: &AnyNameExcept{
      Exclamation: $0.(*expr.Keyword),
      OpenParen: $1.(*expr.Keyword),
      Except: $2.(*NameExpr),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | StartNameChoice
  ;

StartNameChoice
  : OpenParen NameExpr Pipe ContinueNameChoice CloseParen <<
    &NameExpr{NameChoice: &NameChoice{
      OpenParen: $0.(*expr.Keyword),
      Left: $1.(*NameExpr),
      Pipe: $2.(*expr.Keyword),
      Right: $3.(*NameExpr),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  ;

ContinueNameChoice
  : NameExpr
  | ContinueNameChoice Pipe NameExpr <<
    &NameExpr{NameChoice: &NameChoice{
      Left: $0.(*NameExpr),
      Pipe: $1.(*expr.Keyword),
      Right: $2.(*NameExpr),
    }}, nil
  >>
  ;

Empty
  : "<empty>" << &expr.Keyword{Value: "<empty>"}, nil >>
  | Space "<empty>" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "<empty>",
    }, nil
  >>
  ;

EmptySet
  : "<emptyset>" << &expr.Keyword{Value: "<emptyset>"}, nil >>
  | Space "<emptyset>" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "<emptyset>",
    }, nil
  >>
  ;

DepthPattern
  : StartConcat
  | Dot TreeNode << &Pattern{WithSomeTreeNode: &WithSomeTreeNode{
      Dot: $0.(*expr.Keyword),
      Pattern: $1.(*Pattern),
    }}, nil
  >>
  | RightArrow Function <<
    &Pattern{LeafNode: &LeafNode{
        RightArrow: $0.(*expr.Keyword),
        Expr: &expr.Expr{Function: $1.(*expr.Function)},
    }}, nil
  >> 
  | BuiltIn <<
    &Pattern{LeafNode: &LeafNode{
        Expr: &expr.Expr{BuiltIn: $0.(*expr.BuiltIn)},
    }}, nil
  >> 
  ;

TreeNode
  : NameExpr Colon Pattern <<
    &Pattern{TreeNode: &TreeNode{
      Name: $0.(*NameExpr),
      Colon: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
    }}, nil
  >>
  | NameExpr DepthPattern <<
    &Pattern{TreeNode: &TreeNode{
      Name: $0.(*NameExpr),
      Pattern: $1.(*Pattern),
    }}, nil
  >>
  ;

Pattern
  : Empty << &Pattern{Empty: &Empty{$0.(*expr.Keyword)}}, nil >>
  | EmptySet  << &Pattern{EmptySet: &EmptySet{$0.(*expr.Keyword)}}, nil >>
  | Star   << &Pattern{ZAny: &ZAny{Star: $0.(*expr.Keyword)}}, nil >>
  | TreeNode
  | DepthPattern
  | StartOr
  | StartAnd
  | OpenParen Pattern CloseParen Star <<
    &Pattern{ZeroOrMore: &ZeroOrMore{
      OpenParen: $0.(*expr.Keyword),
      Pattern: $1.(*Pattern),
      CloseParen: $2.(*expr.Keyword),
      Star: $3.(*expr.Keyword),
    }}, nil
  >>
  | OpenParen Pattern CloseParen Star <<
    &Pattern{ZeroOrMore: &ZeroOrMore{
      OpenParen: $0.(*expr.Keyword),
      Pattern: $1.(*Pattern),
      CloseParen: $2.(*expr.Keyword),
      Star: $3.(*expr.Keyword),
    }}, nil
  >>
  | HashTag id <<
    &Pattern{Reference: &Reference{
      HashTag: $0.(*expr.Keyword),
      Name: newString($1),
    }}, nil
  >>
  | Exclamation OpenParen Pattern CloseParen <<
    &Pattern{Not: &Not{
      Exclamation: $0.(*expr.Keyword),
      OpenParen: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  ;

StartConcat
  : OpenBracket Pattern Comma ContinueConcat CloseBracket <<
    &Pattern{Concat: &Concat{
      OpenBracket: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Comma: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      CloseBracket: $4.(*expr.Keyword),
    }}, nil
  >>
  | OpenBracket Pattern Comma ContinueConcat Comma CloseBracket <<
    &Pattern{Concat: &Concat{
      OpenBracket: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Comma: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      ExtraComma: $4.(*expr.Keyword),
      CloseBracket: $5.(*expr.Keyword),
    }}, nil
  >>
  ;

ContinueConcat
  : Pattern
  | ContinueConcat Comma Pattern <<
    &Pattern{Concat: &Concat{
      LeftPattern: $0.(*Pattern),
      Comma: $1.(*expr.Keyword),
      RightPattern: $2.(*Pattern),
    }}, nil
  >>
  ;

StartOr
  : OpenParen Pattern Pipe ContinueOr CloseParen <<
    &Pattern{Or: &Or{
      OpenParen: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Pipe: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  ;

ContinueOr
  : Pattern
  | ContinueOr Pipe Pattern <<
    &Pattern{Or: &Or{
      LeftPattern: $0.(*Pattern),
      Pipe: $1.(*expr.Keyword),
      RightPattern: $2.(*Pattern),
    }}, nil
  >>
  ;

StartAnd
  : OpenParen Pattern Ampersand ContinueAnd CloseParen <<
    &Pattern{And: &And{
      OpenParen: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Ampersand: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  ;

ContinueAnd
  : Pattern
  | ContinueAnd Ampersand Pattern <<
    &Pattern{And: &And{
      LeftPattern: $0.(*Pattern),
      Ampersand: $1.(*expr.Keyword),
      RightPattern: $2.(*Pattern),
    }}, nil
  >>
  ;
Start
  : Expr Space
  | Expr
  | BuiltIn Space << &expr.Expr{BuiltIn: $0.(*expr.BuiltIn)}, nil >>
  | BuiltIn << &expr.Expr{BuiltIn: $0.(*expr.BuiltIn)}, nil >>
  ;

Expr
  : SpaceTerminal << &expr.Expr{Terminal: $0.(*expr.Terminal)}, nil >>
  | Function << &expr.Expr{Function: $0.(*expr.Function)}, nil >>
  | List << &expr.Expr{List: $0.(*expr.List)}, nil >>
  ;

Function
  : Space id OpenParen Exprs CloseParen << &expr.Function{Before: $0.(*expr.Space), Name: newString($1), OpenParen: $2.(*expr.Keyword), Params: $3.([]*expr.Expr), CloseParen: $4.(*expr.Keyword)}, nil >>
  | Space id OpenParen CloseParen << &expr.Function{Before: $0.(*expr.Space), Name: newString($1), OpenParen: $2.(*expr.Keyword), CloseParen: $3.(*expr.Keyword)}, nil >>
  | id OpenParen Exprs CloseParen << &expr.Function{Name: newString($0), OpenParen: $1.(*expr.Keyword), Params: $2.([]*expr.Expr), CloseParen: $3.(*expr.Keyword)}, nil >>
  | id OpenParen CloseParen << &expr.Function{Name: newString($0), OpenParen: $1.(*expr.Keyword), CloseParen: $2.(*expr.Keyword)}, nil >>
  ;

BuiltIn
  : EqualEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | ExclamationEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | LessThan Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | GreaterThan Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | GreaterEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | LessEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | TildeEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | StarEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | CaretEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | DollarEqual Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  | ColonColon Expr << &expr.BuiltIn{Symbol: $0.(*expr.Keyword), Expr: $1.(*expr.Expr)}, nil >>
  ;

List
  : Space ListType OpenCurly Exprs CloseCurly << &expr.List{Before: $0.(*expr.Space), Type: $1.(types.Type), OpenCurly: $2.(*expr.Keyword), Elems: $3.([]*expr.Expr), CloseCurly: $4.(*expr.Keyword)}, nil >>
  | ListType OpenCurly Exprs CloseCurly << &expr.List{Type: $0.(types.Type), OpenCurly: $1.(*expr.Keyword), Elems: $2.([]*expr.Expr), CloseCurly: $3.(*expr.Keyword)}, nil >>
  | Space ListType OpenCurly CloseCurly << &expr.List{Before: $0.(*expr.Space), Type: $1.(types.Type), OpenCurly: $2.(*expr.Keyword), CloseCurly: $3.(*expr.Keyword)}, nil >>
  | ListType OpenCurly CloseCurly << &expr.List{Type: $0.(types.Type), OpenCurly: $1.(*expr.Keyword), CloseCurly: $2.(*expr.Keyword)}, nil >>
  ;

Exprs
  : Expr << []*expr.Expr{$0.(*expr.Expr)}, nil >>
  | Exprs Comma Expr << append($0.([]*expr.Expr), expr.SetExprComma($2, $1)), nil >>
  ;

ListType
  : "[]bool" << types.LIST_BOOL, nil >>
  | "[]int" << types.LIST_INT, nil >>
  | "[]uint" << types.LIST_UINT, nil >>
  | "[]double" << types.LIST_DOUBLE, nil >>
  | "[]string" << types.LIST_STRING, nil >>
  | "[][]byte" << types.LIST_BYTES, nil >>
  ;

SpaceTerminal
  : Terminal << $0, nil >>
  | Space Terminal << expr.SetTerminalSpace($1, $0), nil >>
  ;

Literal
  : Bool << expr.NewBoolTerminal($0), nil >>
  | int_lit << expr.NewIntTerminal(newString($0)) >>
  | uint_lit << expr.NewUintTerminal(newString($0)) >>
  | double_lit << expr.NewDoubleTerminal(newString($0)) >>
  | string_lit << expr.NewStringTerminal(newString($0)) >>
  | bytes_lit << expr.NewBytesTerminal(newString($0)) >>
  ;

Terminal
  : Literal
  | bool_var << expr.NewVariableTerminal(types.SINGLE_BOOL) >>
  | int_var << expr.NewVariableTerminal(types.SINGLE_INT) >>
  | uint_var << expr.NewVariableTerminal(types.SINGLE_UINT) >>
  | double_var << expr.NewVariableTerminal(types.SINGLE_DOUBLE) >>
  | string_var << expr.NewVariableTerminal(types.SINGLE_STRING) >>
  | bytes_var << expr.NewVariableTerminal(types.SINGLE_BYTES) >>
  ;

Bool
  : "true" << true, nil >>
  | "false" << false, nil >>
  ;
Equal
  : "="  << &expr.Keyword{Value: "="}, nil >>
  | Space "=" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "=",
    }, nil
  >>
  ;

OpenParen
  : "(" << &expr.Keyword{Value: "("}, nil >>
  | Space "(" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "(",
    }, nil
  >>
  ;

CloseParen
  : ")" << &expr.Keyword{Value: ")"}, nil >>
  | Space ")" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: ")",
    }, nil
  >>
  ;

OpenCurly
  : "{" << &expr.Keyword{Value: "{"}, nil >>
  | Space "{" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "{",
    }, nil
  >>
  ;

CloseCurly
  : "}" << &expr.Keyword{Value: "}"}, nil >>
  | Space "}" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "}",
    }, nil
  >>
  ;

Comma
  : "," << &expr.Keyword{Value: ","}, nil >>
  | Space "," << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: ",",
    }, nil
  >>
  ;

SemiColon
  : ";" << &expr.Keyword{Value: ";"}, nil >>
  | Space ";" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: ";",
    }, nil
  >>
  ;

HashTag
  : "#" << &expr.Keyword{Value: "#"}, nil >>
  | Space "#" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "#",
    }, nil
  >>
  ;

Ampersand
  : "&" << &expr.Keyword{Value: "&"}, nil >>
  | Space "&" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "&",
    }, nil
  >>
  ;

Pipe
  : "|" << &expr.Keyword{Value: "|"}, nil >>
  | Space "|" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "|",
    }, nil
  >>
  ;

OpenBracket
  : "[" << &expr.Keyword{Value: "["}, nil >>
  | Space "[" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "[",
    }, nil
  >>
  ;

CloseBracket
  : "]" << &expr.Keyword{Value: "]"}, nil >>
  | Space "]" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "]",
    }, nil
  >>
  ;

Colon
  : ":" << &expr.Keyword{Value: ":"}, nil >>
  | Space ":" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: ":",
    }, nil
  >>
  ;

Exclamation
  : "!" << &expr.Keyword{Value: "!"}, nil >>
  | Space "!" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "!",
    }, nil
  >>
  ;

Star
  : "*" << &expr.Keyword{Value: "*"}, nil >>
  | Space "*" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "*",
    }, nil
  >>
  ;

Underscore
  : "_" << &expr.Keyword{Value: "_"}, nil >>
  | Space "_" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "_",
    }, nil
  >>
  ;

Tilde
  : "~" << &expr.Keyword{Value: "~"}, nil >>
  | Space "~" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "~",
    }, nil
  >>
  ;

Dot
  : "." << &expr.Keyword{Value: "."}, nil >>
  | Space "." << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: ".",
    }, nil
  >>
  ;

At
  : "@" << &expr.Keyword{Value: "@"}, nil >>
  | Space "@" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "@",
    }, nil
  >>
  ;

RightArrow
  : "->" << &expr.Keyword{Value: "->"}, nil >>
  | Space "->" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "->",
    }, nil
  >>
  ;

EqualEqual
  : "=="  << &expr.Keyword{Value: "=="}, nil >>
  | Space "==" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "==",
    }, nil
  >>
  ;

ExclamationEqual
  : "!="  << &expr.Keyword{Value: "!="}, nil >>
  | Space "!=" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "!=",
    }, nil
  >>
  ;

LessThan
  : "<"  << &expr.Keyword{Value: "<"}, nil >>
  | Space "<" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "<",
    }, nil
  >>
  ;

GreaterThan
  : ">"  << &expr.Keyword{Value: ">"}, nil >>
  | Space ">" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: ">",
    }, nil
  >>
  ;

LessEqual
  : "<="  << &expr.Keyword{Value: "<="}, nil >>
  | Space "<=" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "<=",
    }, nil
  >>
  ;

GreaterEqual
  : ">="  << &expr.Keyword{Value: ">="}, nil >>
  | Space ">=" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: ">=",
    }, nil
  >>
  ;

TildeEqual
  : "~="  << &expr.Keyword{Value: "~="}, nil >>
  | Space "~=" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "~=",
    }, nil
  >>
  ;

StarEqual
  : "*="  << &expr.Keyword{Value: "*="}, nil >>
  | Space "*=" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "*=",
    }, nil
  >>
  ;

CaretEqual
  : "^="  << &expr.Keyword{Value: "^="}, nil >>
  | Space "^=" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "^=",
    }, nil
  >>
  ;

DollarEqual
  : "$="  << &expr.Keyword{Value: "$="}, nil >>
  | Space "$=" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "$=",
    }, nil
  >>
  ;

ColonColon
  : "::"  << &expr.Keyword{Value: "::"}, nil >>
  | Space "::" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "::",
    }, nil
  >>
  ;

Space
  : Space space << expr.AppendSpace($0, newString($1)), nil >>
  | space << &expr.Space{Space: []string{newString($0)}}, nil >>
  ;
