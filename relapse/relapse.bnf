<< 
import (
  . "github.com/katydid/katydid/relapse/ast"
  "github.com/katydid/katydid/expr/ast"
  "github.com/katydid/katydid/types"
  "github.com/katydid/katydid/relapse/token"
  "strconv"
)

func newString(v interface{}) string {
  t := v.(*token.Token)
  return string(t.Lit)
}

func unquote(s1 string) string {
  s, err := strconv.Unquote(s1)
  if err != nil {
    return s1
  }
  return s
}

>>

Grammar
  : Pattern                     << &Grammar{$0.(*Pattern), nil, nil}, nil >>  
  | Pattern Space               << &Grammar{$0.(*Pattern), nil, $1.(*expr.Space)}, nil >>
  | Pattern PatternDecls        << &Grammar{$0.(*Pattern), $1.([]*PatternDecl), nil}, nil >>
  | Pattern PatternDecls Space  << &Grammar{$0.(*Pattern), $1.([]*PatternDecl), $2.(*expr.Space)}, nil >>
  | PatternDecls                << &Grammar{nil, $0.([]*PatternDecl), nil}, nil >>
  | PatternDecls Space          << &Grammar{nil, $0.([]*PatternDecl), $1.(*expr.Space)}, nil >>
  ;

PatternDecls
  : PatternDecl               << []*PatternDecl{$0.(*PatternDecl)}, nil >>
  | PatternDecls PatternDecl  << append($0.([]*PatternDecl), $1.(*PatternDecl)), nil >>
  ;

PatternDecl
  : At Space id Equal Pattern
  <<
    &PatternDecl{
      At: $0.(*expr.Keyword),
      Before: $1.(*expr.Space),
      Name: newString($2),
      Eq: $3.(*expr.Keyword),
      Pattern: $4.(*Pattern),
    }, nil
  >>
  | At id Equal Pattern
  <<
    &PatternDecl{
      At: $0.(*expr.Keyword),
      Name: newString($1),
      Eq: $2.(*expr.Keyword),
      Pattern: $3.(*Pattern),
    }, nil
  >>
  ;

Name
  : Space string_lit <<
    &NameExpr{Name: &Name{
      Before: $0.(*expr.Space),
      Name: unquote(newString($1)),
    }}, nil
  >>
  | string_lit <<
    &NameExpr{Name: &Name{
      Name: unquote(newString($0)),
    }}, nil
  >>
  | Space id <<
    &NameExpr{Name: &Name{
      Before: $0.(*expr.Space),
      Name: newString($1),
    }}, nil
  >>
  | id <<
    &NameExpr{Name: &Name{
      Name: newString($0),
    }}, nil
  >>
  ;

NameExpr
  : Underscore   << &NameExpr{AnyName: &AnyName{$0.(*expr.Keyword)}}, nil >>
  | Name
  | Exclamation OpenParen NameExpr CloseParen <<
    &NameExpr{AnyNameExcept: &AnyNameExcept{
      Exclamation: $0.(*expr.Keyword),
      OpenParen: $1.(*expr.Keyword),
      Except: $2.(*NameExpr),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | StartNameChoice
  ;

StartNameChoice
  : OpenParen NameExpr Pipe ContinueNameChoice CloseParen <<
    &NameExpr{NameChoice: &NameChoice{
      OpenParen: $0.(*expr.Keyword),
      Left: $1.(*NameExpr),
      Pipe: $2.(*expr.Keyword),
      Right: $3.(*NameExpr),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  ;

ContinueNameChoice
  : NameExpr
  | ContinueNameChoice Pipe NameExpr <<
    &NameExpr{NameChoice: &NameChoice{
      Left: $0.(*NameExpr),
      Pipe: $1.(*expr.Keyword),
      Right: $2.(*NameExpr),
    }}, nil
  >>
  ;

Empty
  : "<empty>" << &expr.Keyword{Value: "<empty>"}, nil >>
  | Space "<empty>" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "<empty>",
    }, nil
  >>
  ;

EmptySet
  : "<emptyset>" << &expr.Keyword{Value: "<emptyset>"}, nil >>
  | Space "<emptyset>" << 
    &expr.Keyword{
      Before: $0.(*expr.Space),
      Value: "<emptyset>",
    }, nil
  >>
  ;

DepthPattern
  : StartConcat
  | Dot TreeNode << &Pattern{WithSomeTreeNode: &WithSomeTreeNode{
      Dot: $0.(*expr.Keyword),
      Pattern: $1.(*Pattern),
    }}, nil
  >>
  ;

TreeNode
  : NameExpr Colon Pattern <<
    &Pattern{TreeNode: &TreeNode{
      Name: $0.(*NameExpr),
      Colon: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
    }}, nil
  >>
  | NameExpr DepthPattern <<
    &Pattern{TreeNode: &TreeNode{
      Name: $0.(*NameExpr),
      Pattern: $1.(*Pattern),
    }}, nil
  >>
  | NameExpr RightArrow Function <<
    &Pattern{TreeNode: &TreeNode{
      Name: $0.(*NameExpr),
      Pattern: &Pattern{LeafNode: &LeafNode{
        RightArrow: $1.(*expr.Keyword),
        Expr: &expr.Expr{Function: $2.(*expr.Function)},
      }},
    }}, nil
  >> 
  | NameExpr BuiltIn <<
    &Pattern{TreeNode: &TreeNode{
      Name: $0.(*NameExpr),
      Pattern: &Pattern{LeafNode: &LeafNode{
        Expr: &expr.Expr{BuiltIn: $1.(*expr.BuiltIn)},
      }},
    }}, nil
  >> 
  ;

Pattern
  : Empty << &Pattern{Empty: &Empty{$0.(*expr.Keyword)}}, nil >>
  | EmptySet  << &Pattern{EmptySet: &EmptySet{$0.(*expr.Keyword)}}, nil >>
  | Star   << &Pattern{ZAny: &ZAny{Star: $0.(*expr.Keyword)}}, nil >>
  | TreeNode
  | DepthPattern
  | StartOr
  | StartAnd
  | OpenParen Pattern CloseParen Star <<
    &Pattern{ZeroOrMore: &ZeroOrMore{
      OpenParen: $0.(*expr.Keyword),
      Pattern: $1.(*Pattern),
      CloseParen: $2.(*expr.Keyword),
      Star: $3.(*expr.Keyword),
    }}, nil
  >>
  | OpenParen Pattern CloseParen Star <<
    &Pattern{ZeroOrMore: &ZeroOrMore{
      OpenParen: $0.(*expr.Keyword),
      Pattern: $1.(*Pattern),
      CloseParen: $2.(*expr.Keyword),
      Star: $3.(*expr.Keyword),
    }}, nil
  >>
  | HashTag id <<
    &Pattern{Reference: &Reference{
      HashTag: $0.(*expr.Keyword),
      Name: newString($1),
    }}, nil
  >>
  | Exclamation OpenParen Pattern CloseParen <<
    &Pattern{Not: &Not{
      Exclamation: $0.(*expr.Keyword),
      OpenParen: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  ;

StartConcat
  : OpenBracket Pattern Comma ContinueConcat CloseBracket <<
    &Pattern{Concat: &Concat{
      OpenBracket: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Comma: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      CloseBracket: $4.(*expr.Keyword),
    }}, nil
  >>
  | OpenBracket Pattern Comma ContinueConcat Comma CloseBracket <<
    &Pattern{Concat: &Concat{
      OpenBracket: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Comma: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      ExtraComma: $4.(*expr.Keyword),
      CloseBracket: $5.(*expr.Keyword),
    }}, nil
  >>
  ;

ContinueConcat
  : Pattern
  | ContinueConcat Comma Pattern <<
    &Pattern{Concat: &Concat{
      LeftPattern: $0.(*Pattern),
      Comma: $1.(*expr.Keyword),
      RightPattern: $2.(*Pattern),
    }}, nil
  >>
  ;

StartOr
  : OpenParen Pattern Pipe ContinueOr CloseParen <<
    &Pattern{Or: &Or{
      OpenParen: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Pipe: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  ;

ContinueOr
  : Pattern
  | ContinueOr Pipe Pattern <<
    &Pattern{Or: &Or{
      LeftPattern: $0.(*Pattern),
      Pipe: $1.(*expr.Keyword),
      RightPattern: $2.(*Pattern),
    }}, nil
  >>
  ;

StartAnd
  : OpenParen Pattern Ampersand ContinueAnd CloseParen <<
    &Pattern{And: &And{
      OpenParen: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Ampersand: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  ;

ContinueAnd
  : Pattern
  | ContinueAnd Ampersand Pattern <<
    &Pattern{And: &And{
      LeftPattern: $0.(*Pattern),
      Ampersand: $1.(*expr.Keyword),
      RightPattern: $2.(*Pattern),
    }}, nil
  >>
  ;
