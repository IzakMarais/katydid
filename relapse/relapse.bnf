<< 
import (
  . "github.com/katydid/katydid/relapse/ast"
  "github.com/katydid/katydid/expr/ast"
  "github.com/katydid/katydid/types"
  "github.com/katydid/katydid/relapse/token"
  "strconv"
)

func newString(v interface{}) string {
  t := v.(*token.Token)
  return string(t.Lit)
}

func unquote(s1 string) string {
  s, err := strconv.Unquote(s1)
  if err != nil {
    return s1
  }
  return s
}

>>

Grammar
  : PatternDecls       << &Grammar{$0.([]*PatternDecl), nil}, nil >>
  | PatternDecls Space << &Grammar{$0.([]*PatternDecl), $1.(*expr.Space)}, nil >>
  ;

PatternDecls
  : PatternDecl               << []*PatternDecl{$0.(*PatternDecl)}, nil >>
  | PatternDecls PatternDecl  << append($0.([]*PatternDecl), $1.(*PatternDecl)), nil >>
  ;

PatternDecl
  : Space id Equal Pattern
  <<
    &PatternDecl{
      Before: $0.(*expr.Space),
      Name: newString($1),
      Eq: $2.(*expr.Keyword),
      Pattern: $3.(*Pattern),
    }, nil
  >>
  | id Equal Pattern
  <<
    &PatternDecl{
      Name: newString($0),
      Eq: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
    }, nil
  >>
  ;

NameExpr
  : Space "AnyName"     << &NameExpr{AnyName: &AnyName{$0.(*expr.Space)}}, nil >>
  | "AnyName"           << &NameExpr{AnyName: &AnyName{}}, nil >>
  | Space "Name" OpenParen Space string_lit CloseParen <<
    &NameExpr{Name: &Name{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      BeforeName: $3.(*expr.Space),
      Name: unquote(newString($4)),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  | "Name" OpenParen Space string_lit CloseParen <<
    &NameExpr{Name: &Name{
      OpenParen: $1.(*expr.Keyword),
      BeforeName: $2.(*expr.Space),
      Name: unquote(newString($3)),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | Space "Name" OpenParen string_lit CloseParen <<
    &NameExpr{Name: &Name{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Name: unquote(newString($3)),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | "Name" OpenParen string_lit CloseParen <<
    &NameExpr{Name: &Name{
      OpenParen: $1.(*expr.Keyword),
      Name: unquote(newString($2)),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | Space "AnyNameExcept" OpenParen NameExpr CloseParen <<
    &NameExpr{AnyNameExcept: &AnyNameExcept{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Except: $3.(*NameExpr),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | "AnyNameExcept" OpenParen NameExpr CloseParen <<
    &NameExpr{AnyNameExcept: &AnyNameExcept{
      OpenParen: $1.(*expr.Keyword),
      Except: $2.(*NameExpr),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | Space "NameChoice" OpenParen NameExpr Comma NameExpr CloseParen <<
    &NameExpr{NameChoice: &NameChoice{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Left: $3.(*NameExpr),
      Comma: $4.(*expr.Keyword),
      Right: $5.(*NameExpr),
      CloseParen: $6.(*expr.Keyword),
    }}, nil
  >>
  | "NameChoice" OpenParen NameExpr Comma NameExpr CloseParen <<
    &NameExpr{NameChoice: &NameChoice{
      OpenParen: $1.(*expr.Keyword),
      Left: $2.(*NameExpr),
      Comma: $3.(*expr.Keyword),
      Right: $4.(*NameExpr),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  ;

Pattern
  : Space "Empty"     << &Pattern{Empty: &Empty{$0.(*expr.Space)}}, nil >>
  | "Empty"     << &Pattern{Empty: &Empty{}}, nil >>
  | Space "EmptySet"  << &Pattern{EmptySet: &EmptySet{$0.(*expr.Space)}}, nil >>
  | "EmptySet"  << &Pattern{EmptySet: &EmptySet{}}, nil >>
  | NameExpr Colon Pattern <<
    &Pattern{TreeNode: &TreeNode{
      Name: $0.(*NameExpr),
      Colon: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
    }}, nil
  >>
  | Expr <<
    &Pattern{LeafNode: &LeafNode{
      Expr: $0.(*expr.Expr),
    }}, nil
  >>
  | OpenBracket Pattern Comma Pattern CloseBracket <<
    &Pattern{Concat: &Concat{
      OpenBracket: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Comma: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      CloseBracket: $4.(*expr.Keyword),
    }}, nil
  >>
  | OpenParen Pattern Pipe Pattern CloseParen <<
    &Pattern{Or: &Or{
      OpenParen: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Pipe: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | OpenParen Pattern Ampersand Pattern CloseParen <<
    &Pattern{And: &And{
      OpenParen: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Ampersand: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | Space "ZeroOrMore" OpenParen Pattern CloseParen <<
    &Pattern{ZeroOrMore: &ZeroOrMore{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Pattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | "ZeroOrMore" OpenParen Pattern CloseParen <<
    &Pattern{ZeroOrMore: &ZeroOrMore{
      OpenParen: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | HashTag id <<
    &Pattern{Reference: &Reference{
      HashTag: $0.(*expr.Keyword),
      Name: newString($1),
    }}, nil
  >>
  | Exclamation OpenParen Pattern CloseParen <<
    &Pattern{Not: &Not{
      Exclamation: $0.(*expr.Keyword),
      OpenParen: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  // | Interleave Pattern Pattern -- New 
  ;





