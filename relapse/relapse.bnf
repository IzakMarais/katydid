<< 
import (
  . "github.com/katydid/katydid/relapse/ast"
  "github.com/katydid/katydid/expr/ast"
  "github.com/katydid/katydid/types"
  "github.com/katydid/katydid/relapse/token"
  "strconv"
)

func newString(v interface{}) string {
  t := v.(*token.Token)
  return string(t.Lit)
}

func unquote(s1 string) string {
  s, err := strconv.Unquote(s1)
  if err != nil {
    return s1
  }
  return s
}

>>

Grammar
  : PatternDecls       << &Grammar{$0.([]*PatternDecl), nil}, nil >>
  | PatternDecls Space << &Grammar{$0.([]*PatternDecl), $1.(*expr.Space)}, nil >>
  ;

PatternDecls
  : PatternDecl               << []*PatternDecl{$0.(*PatternDecl)}, nil >>
  | PatternDecls PatternDecl  << append($0.([]*PatternDecl), $1.(*PatternDecl)), nil >>
  ;

PatternDecl
  : Space id Equal Pattern
  <<
    &PatternDecl{
      Before: $0.(*expr.Space),
      Name: newString($1),
      Eq: $2.(*expr.Keyword),
      Pattern: $3.(*Pattern),
    }, nil
  >>
  | id Equal Pattern
  <<
    &PatternDecl{
      Name: newString($0),
      Eq: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
    }, nil
  >>
  ;

NameExpr
  : Space "AnyName"     << &NameExpr{AnyName: &AnyName{$0.(*expr.Space)}}, nil >>
  | "AnyName"           << &NameExpr{AnyName: &AnyName{}}, nil >>
  | Space string_lit <<
    &NameExpr{Name: &Name{
      Before: $0.(*expr.Space),
      Name: unquote(newString($1)),
    }}, nil
  >>
  | string_lit <<
    &NameExpr{Name: &Name{
      Name: unquote(newString($0)),
    }}, nil
  >>
  | Space "AnyNameExcept" OpenParen NameExpr CloseParen <<
    &NameExpr{AnyNameExcept: &AnyNameExcept{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Except: $3.(*NameExpr),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  | "AnyNameExcept" OpenParen NameExpr CloseParen <<
    &NameExpr{AnyNameExcept: &AnyNameExcept{
      OpenParen: $1.(*expr.Keyword),
      Except: $2.(*NameExpr),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  | Space "NameChoice" OpenParen NameExpr Comma NameExpr CloseParen <<
    &NameExpr{NameChoice: &NameChoice{
      Before: $0.(*expr.Space),
      OpenParen: $2.(*expr.Keyword),
      Left: $3.(*NameExpr),
      Comma: $4.(*expr.Keyword),
      Right: $5.(*NameExpr),
      CloseParen: $6.(*expr.Keyword),
    }}, nil
  >>
  | "NameChoice" OpenParen NameExpr Comma NameExpr CloseParen <<
    &NameExpr{NameChoice: &NameChoice{
      OpenParen: $1.(*expr.Keyword),
      Left: $2.(*NameExpr),
      Comma: $3.(*expr.Keyword),
      Right: $4.(*NameExpr),
      CloseParen: $5.(*expr.Keyword),
    }}, nil
  >>
  ;

Pattern
  : Space "Empty"     << &Pattern{Empty: &Empty{$0.(*expr.Space)}}, nil >>
  | "Empty"     << &Pattern{Empty: &Empty{}}, nil >>
  | Space "EmptySet"  << &Pattern{EmptySet: &EmptySet{$0.(*expr.Space)}}, nil >>
  | "EmptySet"  << &Pattern{EmptySet: &EmptySet{}}, nil >>
  | NameExpr Colon Pattern <<
    &Pattern{TreeNode: &TreeNode{
      Name: $0.(*NameExpr),
      Colon: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
    }}, nil
  >>
  | OpenCurly Expr CloseCurly <<
    &Pattern{LeafNode: &LeafNode{
      OpenCurly: $0.(*expr.Keyword),
      Expr: $1.(*expr.Expr),
      CloseCurly: $2.(*expr.Keyword),
    }}, nil
  >>
  | StartConcat
  | StartOr
  | StartAnd
  | OpenParen Pattern CloseParen Star <<
    &Pattern{ZeroOrMore: &ZeroOrMore{
      OpenParen: $0.(*expr.Keyword),
      Pattern: $1.(*Pattern),
      CloseParen: $2.(*expr.Keyword),
      Star: $3.(*expr.Keyword),
    }}, nil
  >>
  | OpenParen Pattern CloseParen Star <<
    &Pattern{ZeroOrMore: &ZeroOrMore{
      OpenParen: $0.(*expr.Keyword),
      Pattern: $1.(*Pattern),
      CloseParen: $2.(*expr.Keyword),
      Star: $3.(*expr.Keyword),
    }}, nil
  >>
  | HashTag id <<
    &Pattern{Reference: &Reference{
      HashTag: $0.(*expr.Keyword),
      Name: newString($1),
    }}, nil
  >>
  | Exclamation OpenParen Pattern CloseParen <<
    &Pattern{Not: &Not{
      Exclamation: $0.(*expr.Keyword),
      OpenParen: $1.(*expr.Keyword),
      Pattern: $2.(*Pattern),
      CloseParen: $3.(*expr.Keyword),
    }}, nil
  >>
  // | Interleave Pattern Pattern -- New 
  ;

StartConcat
  : OpenBracket Pattern Comma ContinueConcat CloseBracket <<
    &Pattern{Concat: &Concat{
      OpenBracket: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Comma: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      CloseBracket: $4.(*expr.Keyword),
    }}, nil
  >>
  ;

ContinueConcat
  : Pattern
  | ContinueConcat Comma Pattern <<
    &Pattern{Concat: &Concat{
      LeftPattern: $0.(*Pattern),
      Comma: $1.(*expr.Keyword),
      RightPattern: $2.(*Pattern),
    }}, nil
  >>
  ;

StartOr
  : OpenParen Pattern Pipe ContinueOr CloseParen <<
    &Pattern{Or: &Or{
      OpenParen: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Pipe: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  ;

ContinueOr
  : Pattern
  | ContinueOr Pipe Pattern <<
    &Pattern{Or: &Or{
      LeftPattern: $0.(*Pattern),
      Pipe: $1.(*expr.Keyword),
      RightPattern: $2.(*Pattern),
    }}, nil
  >>
  ;

StartAnd
  : OpenParen Pattern Ampersand ContinueAnd CloseParen <<
    &Pattern{And: &And{
      OpenParen: $0.(*expr.Keyword),
      LeftPattern: $1.(*Pattern),
      Ampersand: $2.(*expr.Keyword),
      RightPattern: $3.(*Pattern),
      CloseParen: $4.(*expr.Keyword),
    }}, nil
  >>
  ;

ContinueAnd
  : Pattern
  | ContinueAnd Ampersand Pattern <<
    &Pattern{And: &And{
      LeftPattern: $0.(*Pattern),
      Ampersand: $1.(*expr.Keyword),
      RightPattern: $2.(*Pattern),
    }}, nil
  >>
  ;


