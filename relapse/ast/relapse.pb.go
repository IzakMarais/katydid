// Code generated by protoc-gen-gogo.
// source: relapse.proto
// DO NOT EDIT!

/*
	Package relapse is a generated protocol buffer package.

	It is generated from these files:
		relapse.proto

	It has these top-level messages:
		Grammar
		PatternDecl
		NameExpr
		Name
		AnyName
		AnyNameExcept
		NameChoice
		Pattern
		Empty
		TreeNode
		Contains
		LeafNode
		Concat
		Or
		And
		ZeroOrMore
		Reference
		Not
		ZAny
		Optional
		Interleave
*/
package relapse

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import expr "github.com/katydid/katydid/expr/ast"

import bytes "bytes"

import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Grammar struct {
	TopPattern   *Pattern       `protobuf:"bytes,1,opt,name=TopPattern" json:"TopPattern,omitempty"`
	PatternDecls []*PatternDecl `protobuf:"bytes,2,rep,name=PatternDecls" json:"PatternDecls,omitempty"`
	After        *expr.Space    `protobuf:"bytes,3,opt,name=After" json:"After,omitempty"`
}

func (m *Grammar) Reset()      { *m = Grammar{} }
func (*Grammar) ProtoMessage() {}

func (m *Grammar) GetTopPattern() *Pattern {
	if m != nil {
		return m.TopPattern
	}
	return nil
}

func (m *Grammar) GetPatternDecls() []*PatternDecl {
	if m != nil {
		return m.PatternDecls
	}
	return nil
}

func (m *Grammar) GetAfter() *expr.Space {
	if m != nil {
		return m.After
	}
	return nil
}

type PatternDecl struct {
	Hash    *expr.Keyword `protobuf:"bytes,1,opt,name=Hash" json:"Hash,omitempty"`
	Before  *expr.Space   `protobuf:"bytes,2,opt,name=Before" json:"Before,omitempty"`
	Name    string        `protobuf:"bytes,3,opt,name=Name" json:"Name"`
	Eq      *expr.Keyword `protobuf:"bytes,4,opt,name=Eq" json:"Eq,omitempty"`
	Pattern *Pattern      `protobuf:"bytes,5,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *PatternDecl) Reset()      { *m = PatternDecl{} }
func (*PatternDecl) ProtoMessage() {}

func (m *PatternDecl) GetHash() *expr.Keyword {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *PatternDecl) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *PatternDecl) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PatternDecl) GetEq() *expr.Keyword {
	if m != nil {
		return m.Eq
	}
	return nil
}

func (m *PatternDecl) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

type NameExpr struct {
	Name          *Name          `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	AnyName       *AnyName       `protobuf:"bytes,2,opt,name=AnyName" json:"AnyName,omitempty"`
	AnyNameExcept *AnyNameExcept `protobuf:"bytes,3,opt,name=AnyNameExcept" json:"AnyNameExcept,omitempty"`
	NameChoice    *NameChoice    `protobuf:"bytes,4,opt,name=NameChoice" json:"NameChoice,omitempty"`
}

func (m *NameExpr) Reset()      { *m = NameExpr{} }
func (*NameExpr) ProtoMessage() {}

func (m *NameExpr) GetName() *Name {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *NameExpr) GetAnyName() *AnyName {
	if m != nil {
		return m.AnyName
	}
	return nil
}

func (m *NameExpr) GetAnyNameExcept() *AnyNameExcept {
	if m != nil {
		return m.AnyNameExcept
	}
	return nil
}

func (m *NameExpr) GetNameChoice() *NameChoice {
	if m != nil {
		return m.NameChoice
	}
	return nil
}

type Name struct {
	Before      *expr.Space `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	DoubleValue *float64    `protobuf:"fixed64,3,opt,name=DoubleValue" json:"DoubleValue,omitempty"`
	IntValue    *int64      `protobuf:"varint,5,opt,name=IntValue" json:"IntValue,omitempty"`
	UintValue   *uint64     `protobuf:"varint,6,opt,name=UintValue" json:"UintValue,omitempty"`
	BoolValue   *bool       `protobuf:"varint,8,opt,name=BoolValue" json:"BoolValue,omitempty"`
	StringValue *string     `protobuf:"bytes,9,opt,name=StringValue" json:"StringValue,omitempty"`
	BytesValue  []byte      `protobuf:"bytes,10,opt,name=BytesValue" json:"BytesValue,omitempty"`
}

func (m *Name) Reset()      { *m = Name{} }
func (*Name) ProtoMessage() {}

func (m *Name) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Name) GetDoubleValue() float64 {
	if m != nil && m.DoubleValue != nil {
		return *m.DoubleValue
	}
	return 0
}

func (m *Name) GetIntValue() int64 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *Name) GetUintValue() uint64 {
	if m != nil && m.UintValue != nil {
		return *m.UintValue
	}
	return 0
}

func (m *Name) GetBoolValue() bool {
	if m != nil && m.BoolValue != nil {
		return *m.BoolValue
	}
	return false
}

func (m *Name) GetStringValue() string {
	if m != nil && m.StringValue != nil {
		return *m.StringValue
	}
	return ""
}

func (m *Name) GetBytesValue() []byte {
	if m != nil {
		return m.BytesValue
	}
	return nil
}

type AnyName struct {
	Underscore *expr.Keyword `protobuf:"bytes,1,opt,name=Underscore" json:"Underscore,omitempty"`
}

func (m *AnyName) Reset()      { *m = AnyName{} }
func (*AnyName) ProtoMessage() {}

func (m *AnyName) GetUnderscore() *expr.Keyword {
	if m != nil {
		return m.Underscore
	}
	return nil
}

type AnyNameExcept struct {
	Exclamation *expr.Keyword `protobuf:"bytes,1,opt,name=Exclamation" json:"Exclamation,omitempty"`
	OpenParen   *expr.Keyword `protobuf:"bytes,2,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Except      *NameExpr     `protobuf:"bytes,3,opt,name=Except" json:"Except,omitempty"`
	CloseParen  *expr.Keyword `protobuf:"bytes,4,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *AnyNameExcept) Reset()      { *m = AnyNameExcept{} }
func (*AnyNameExcept) ProtoMessage() {}

func (m *AnyNameExcept) GetExclamation() *expr.Keyword {
	if m != nil {
		return m.Exclamation
	}
	return nil
}

func (m *AnyNameExcept) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *AnyNameExcept) GetExcept() *NameExpr {
	if m != nil {
		return m.Except
	}
	return nil
}

func (m *AnyNameExcept) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type NameChoice struct {
	OpenParen  *expr.Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Left       *NameExpr     `protobuf:"bytes,2,opt,name=Left" json:"Left,omitempty"`
	Pipe       *expr.Keyword `protobuf:"bytes,3,opt,name=Pipe" json:"Pipe,omitempty"`
	Right      *NameExpr     `protobuf:"bytes,4,opt,name=Right" json:"Right,omitempty"`
	CloseParen *expr.Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *NameChoice) Reset()      { *m = NameChoice{} }
func (*NameChoice) ProtoMessage() {}

func (m *NameChoice) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *NameChoice) GetLeft() *NameExpr {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *NameChoice) GetPipe() *expr.Keyword {
	if m != nil {
		return m.Pipe
	}
	return nil
}

func (m *NameChoice) GetRight() *NameExpr {
	if m != nil {
		return m.Right
	}
	return nil
}

func (m *NameChoice) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type Pattern struct {
	Empty      *Empty      `protobuf:"bytes,1,opt,name=Empty" json:"Empty,omitempty"`
	TreeNode   *TreeNode   `protobuf:"bytes,3,opt,name=TreeNode" json:"TreeNode,omitempty"`
	LeafNode   *LeafNode   `protobuf:"bytes,4,opt,name=LeafNode" json:"LeafNode,omitempty"`
	Concat     *Concat     `protobuf:"bytes,5,opt,name=Concat" json:"Concat,omitempty"`
	Or         *Or         `protobuf:"bytes,6,opt,name=Or" json:"Or,omitempty"`
	And        *And        `protobuf:"bytes,7,opt,name=And" json:"And,omitempty"`
	ZeroOrMore *ZeroOrMore `protobuf:"bytes,8,opt,name=ZeroOrMore" json:"ZeroOrMore,omitempty"`
	Reference  *Reference  `protobuf:"bytes,9,opt,name=Reference" json:"Reference,omitempty"`
	Not        *Not        `protobuf:"bytes,10,opt,name=Not" json:"Not,omitempty"`
	ZAny       *ZAny       `protobuf:"bytes,11,opt,name=ZAny" json:"ZAny,omitempty"`
	Contains   *Contains   `protobuf:"bytes,12,opt,name=Contains" json:"Contains,omitempty"`
	Optional   *Optional   `protobuf:"bytes,13,opt,name=Optional" json:"Optional,omitempty"`
	Interleave *Interleave `protobuf:"bytes,14,opt,name=Interleave" json:"Interleave,omitempty"`
}

func (m *Pattern) Reset()      { *m = Pattern{} }
func (*Pattern) ProtoMessage() {}

func (m *Pattern) GetEmpty() *Empty {
	if m != nil {
		return m.Empty
	}
	return nil
}

func (m *Pattern) GetTreeNode() *TreeNode {
	if m != nil {
		return m.TreeNode
	}
	return nil
}

func (m *Pattern) GetLeafNode() *LeafNode {
	if m != nil {
		return m.LeafNode
	}
	return nil
}

func (m *Pattern) GetConcat() *Concat {
	if m != nil {
		return m.Concat
	}
	return nil
}

func (m *Pattern) GetOr() *Or {
	if m != nil {
		return m.Or
	}
	return nil
}

func (m *Pattern) GetAnd() *And {
	if m != nil {
		return m.And
	}
	return nil
}

func (m *Pattern) GetZeroOrMore() *ZeroOrMore {
	if m != nil {
		return m.ZeroOrMore
	}
	return nil
}

func (m *Pattern) GetReference() *Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *Pattern) GetNot() *Not {
	if m != nil {
		return m.Not
	}
	return nil
}

func (m *Pattern) GetZAny() *ZAny {
	if m != nil {
		return m.ZAny
	}
	return nil
}

func (m *Pattern) GetContains() *Contains {
	if m != nil {
		return m.Contains
	}
	return nil
}

func (m *Pattern) GetOptional() *Optional {
	if m != nil {
		return m.Optional
	}
	return nil
}

func (m *Pattern) GetInterleave() *Interleave {
	if m != nil {
		return m.Interleave
	}
	return nil
}

type Empty struct {
	Empty *expr.Keyword `protobuf:"bytes,1,opt,name=Empty" json:"Empty,omitempty"`
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}

func (m *Empty) GetEmpty() *expr.Keyword {
	if m != nil {
		return m.Empty
	}
	return nil
}

type TreeNode struct {
	Name    *NameExpr     `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Colon   *expr.Keyword `protobuf:"bytes,2,opt,name=Colon" json:"Colon,omitempty"`
	Pattern *Pattern      `protobuf:"bytes,3,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *TreeNode) Reset()      { *m = TreeNode{} }
func (*TreeNode) ProtoMessage() {}

func (m *TreeNode) GetName() *NameExpr {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *TreeNode) GetColon() *expr.Keyword {
	if m != nil {
		return m.Colon
	}
	return nil
}

func (m *TreeNode) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

type Contains struct {
	Dot     *expr.Keyword `protobuf:"bytes,1,opt,name=Dot" json:"Dot,omitempty"`
	Pattern *Pattern      `protobuf:"bytes,2,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *Contains) Reset()      { *m = Contains{} }
func (*Contains) ProtoMessage() {}

func (m *Contains) GetDot() *expr.Keyword {
	if m != nil {
		return m.Dot
	}
	return nil
}

func (m *Contains) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

type LeafNode struct {
	RightArrow *expr.Keyword `protobuf:"bytes,1,opt,name=RightArrow" json:"RightArrow,omitempty"`
	Expr       *expr.Expr    `protobuf:"bytes,2,opt,name=Expr" json:"Expr,omitempty"`
}

func (m *LeafNode) Reset()      { *m = LeafNode{} }
func (*LeafNode) ProtoMessage() {}

func (m *LeafNode) GetRightArrow() *expr.Keyword {
	if m != nil {
		return m.RightArrow
	}
	return nil
}

func (m *LeafNode) GetExpr() *expr.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

type Concat struct {
	OpenBracket  *expr.Keyword `protobuf:"bytes,2,opt,name=OpenBracket" json:"OpenBracket,omitempty"`
	LeftPattern  *Pattern      `protobuf:"bytes,3,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	Comma        *expr.Keyword `protobuf:"bytes,4,opt,name=Comma" json:"Comma,omitempty"`
	RightPattern *Pattern      `protobuf:"bytes,5,opt,name=RightPattern" json:"RightPattern,omitempty"`
	ExtraComma   *expr.Keyword `protobuf:"bytes,6,opt,name=ExtraComma" json:"ExtraComma,omitempty"`
	CloseBracket *expr.Keyword `protobuf:"bytes,7,opt,name=CloseBracket" json:"CloseBracket,omitempty"`
}

func (m *Concat) Reset()      { *m = Concat{} }
func (*Concat) ProtoMessage() {}

func (m *Concat) GetOpenBracket() *expr.Keyword {
	if m != nil {
		return m.OpenBracket
	}
	return nil
}

func (m *Concat) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *Concat) GetComma() *expr.Keyword {
	if m != nil {
		return m.Comma
	}
	return nil
}

func (m *Concat) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *Concat) GetExtraComma() *expr.Keyword {
	if m != nil {
		return m.ExtraComma
	}
	return nil
}

func (m *Concat) GetCloseBracket() *expr.Keyword {
	if m != nil {
		return m.CloseBracket
	}
	return nil
}

type Or struct {
	OpenParen    *expr.Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	LeftPattern  *Pattern      `protobuf:"bytes,2,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	Pipe         *expr.Keyword `protobuf:"bytes,3,opt,name=Pipe" json:"Pipe,omitempty"`
	RightPattern *Pattern      `protobuf:"bytes,4,opt,name=RightPattern" json:"RightPattern,omitempty"`
	CloseParen   *expr.Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *Or) Reset()      { *m = Or{} }
func (*Or) ProtoMessage() {}

func (m *Or) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Or) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *Or) GetPipe() *expr.Keyword {
	if m != nil {
		return m.Pipe
	}
	return nil
}

func (m *Or) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *Or) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type And struct {
	OpenParen    *expr.Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	LeftPattern  *Pattern      `protobuf:"bytes,2,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	Ampersand    *expr.Keyword `protobuf:"bytes,3,opt,name=Ampersand" json:"Ampersand,omitempty"`
	RightPattern *Pattern      `protobuf:"bytes,4,opt,name=RightPattern" json:"RightPattern,omitempty"`
	CloseParen   *expr.Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *And) Reset()      { *m = And{} }
func (*And) ProtoMessage() {}

func (m *And) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *And) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *And) GetAmpersand() *expr.Keyword {
	if m != nil {
		return m.Ampersand
	}
	return nil
}

func (m *And) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *And) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type ZeroOrMore struct {
	OpenParen  *expr.Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Pattern    *Pattern      `protobuf:"bytes,2,opt,name=Pattern" json:"Pattern,omitempty"`
	CloseParen *expr.Keyword `protobuf:"bytes,3,opt,name=CloseParen" json:"CloseParen,omitempty"`
	Star       *expr.Keyword `protobuf:"bytes,4,opt,name=Star" json:"Star,omitempty"`
}

func (m *ZeroOrMore) Reset()      { *m = ZeroOrMore{} }
func (*ZeroOrMore) ProtoMessage() {}

func (m *ZeroOrMore) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *ZeroOrMore) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *ZeroOrMore) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

func (m *ZeroOrMore) GetStar() *expr.Keyword {
	if m != nil {
		return m.Star
	}
	return nil
}

type Reference struct {
	At   *expr.Keyword `protobuf:"bytes,1,opt,name=At" json:"At,omitempty"`
	Name string        `protobuf:"bytes,2,opt,name=Name" json:"Name"`
}

func (m *Reference) Reset()      { *m = Reference{} }
func (*Reference) ProtoMessage() {}

func (m *Reference) GetAt() *expr.Keyword {
	if m != nil {
		return m.At
	}
	return nil
}

func (m *Reference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Not struct {
	Exclamation *expr.Keyword `protobuf:"bytes,1,opt,name=Exclamation" json:"Exclamation,omitempty"`
	OpenParen   *expr.Keyword `protobuf:"bytes,2,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Pattern     *Pattern      `protobuf:"bytes,3,opt,name=Pattern" json:"Pattern,omitempty"`
	CloseParen  *expr.Keyword `protobuf:"bytes,4,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *Not) Reset()      { *m = Not{} }
func (*Not) ProtoMessage() {}

func (m *Not) GetExclamation() *expr.Keyword {
	if m != nil {
		return m.Exclamation
	}
	return nil
}

func (m *Not) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Not) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *Not) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type ZAny struct {
	Star *expr.Keyword `protobuf:"bytes,1,opt,name=Star" json:"Star,omitempty"`
}

func (m *ZAny) Reset()      { *m = ZAny{} }
func (*ZAny) ProtoMessage() {}

func (m *ZAny) GetStar() *expr.Keyword {
	if m != nil {
		return m.Star
	}
	return nil
}

type Optional struct {
	OpenParen    *expr.Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Pattern      *Pattern      `protobuf:"bytes,2,opt,name=Pattern" json:"Pattern,omitempty"`
	CloseParen   *expr.Keyword `protobuf:"bytes,3,opt,name=CloseParen" json:"CloseParen,omitempty"`
	QuestionMark *expr.Keyword `protobuf:"bytes,4,opt,name=QuestionMark" json:"QuestionMark,omitempty"`
}

func (m *Optional) Reset()      { *m = Optional{} }
func (*Optional) ProtoMessage() {}

func (m *Optional) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Optional) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *Optional) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

func (m *Optional) GetQuestionMark() *expr.Keyword {
	if m != nil {
		return m.QuestionMark
	}
	return nil
}

type Interleave struct {
	OpenCurly      *expr.Keyword `protobuf:"bytes,2,opt,name=OpenCurly" json:"OpenCurly,omitempty"`
	LeftPattern    *Pattern      `protobuf:"bytes,3,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	SemiColon      *expr.Keyword `protobuf:"bytes,4,opt,name=SemiColon" json:"SemiColon,omitempty"`
	RightPattern   *Pattern      `protobuf:"bytes,5,opt,name=RightPattern" json:"RightPattern,omitempty"`
	ExtraSemiColon *expr.Keyword `protobuf:"bytes,6,opt,name=ExtraSemiColon" json:"ExtraSemiColon,omitempty"`
	CloseCurly     *expr.Keyword `protobuf:"bytes,7,opt,name=CloseCurly" json:"CloseCurly,omitempty"`
}

func (m *Interleave) Reset()      { *m = Interleave{} }
func (*Interleave) ProtoMessage() {}

func (m *Interleave) GetOpenCurly() *expr.Keyword {
	if m != nil {
		return m.OpenCurly
	}
	return nil
}

func (m *Interleave) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *Interleave) GetSemiColon() *expr.Keyword {
	if m != nil {
		return m.SemiColon
	}
	return nil
}

func (m *Interleave) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *Interleave) GetExtraSemiColon() *expr.Keyword {
	if m != nil {
		return m.ExtraSemiColon
	}
	return nil
}

func (m *Interleave) GetCloseCurly() *expr.Keyword {
	if m != nil {
		return m.CloseCurly
	}
	return nil
}

func init() {
	proto.RegisterType((*Grammar)(nil), "relapse.Grammar")
	proto.RegisterType((*PatternDecl)(nil), "relapse.PatternDecl")
	proto.RegisterType((*NameExpr)(nil), "relapse.NameExpr")
	proto.RegisterType((*Name)(nil), "relapse.Name")
	proto.RegisterType((*AnyName)(nil), "relapse.AnyName")
	proto.RegisterType((*AnyNameExcept)(nil), "relapse.AnyNameExcept")
	proto.RegisterType((*NameChoice)(nil), "relapse.NameChoice")
	proto.RegisterType((*Pattern)(nil), "relapse.Pattern")
	proto.RegisterType((*Empty)(nil), "relapse.Empty")
	proto.RegisterType((*TreeNode)(nil), "relapse.TreeNode")
	proto.RegisterType((*Contains)(nil), "relapse.Contains")
	proto.RegisterType((*LeafNode)(nil), "relapse.LeafNode")
	proto.RegisterType((*Concat)(nil), "relapse.Concat")
	proto.RegisterType((*Or)(nil), "relapse.Or")
	proto.RegisterType((*And)(nil), "relapse.And")
	proto.RegisterType((*ZeroOrMore)(nil), "relapse.ZeroOrMore")
	proto.RegisterType((*Reference)(nil), "relapse.Reference")
	proto.RegisterType((*Not)(nil), "relapse.Not")
	proto.RegisterType((*ZAny)(nil), "relapse.ZAny")
	proto.RegisterType((*Optional)(nil), "relapse.Optional")
	proto.RegisterType((*Interleave)(nil), "relapse.Interleave")
}
func (this *Grammar) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Grammar)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.TopPattern.Equal(that1.TopPattern) {
		return false
	}
	if len(this.PatternDecls) != len(that1.PatternDecls) {
		return false
	}
	for i := range this.PatternDecls {
		if !this.PatternDecls[i].Equal(that1.PatternDecls[i]) {
			return false
		}
	}
	if !this.After.Equal(that1.After) {
		return false
	}
	return true
}
func (this *PatternDecl) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PatternDecl)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Hash.Equal(that1.Hash) {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Eq.Equal(that1.Eq) {
		return false
	}
	if !this.Pattern.Equal(that1.Pattern) {
		return false
	}
	return true
}
func (this *NameExpr) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NameExpr)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Name.Equal(that1.Name) {
		return false
	}
	if !this.AnyName.Equal(that1.AnyName) {
		return false
	}
	if !this.AnyNameExcept.Equal(that1.AnyNameExcept) {
		return false
	}
	if !this.NameChoice.Equal(that1.NameChoice) {
		return false
	}
	return true
}
func (this *Name) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Name)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if this.DoubleValue != nil && that1.DoubleValue != nil {
		if *this.DoubleValue != *that1.DoubleValue {
			return false
		}
	} else if this.DoubleValue != nil {
		return false
	} else if that1.DoubleValue != nil {
		return false
	}
	if this.IntValue != nil && that1.IntValue != nil {
		if *this.IntValue != *that1.IntValue {
			return false
		}
	} else if this.IntValue != nil {
		return false
	} else if that1.IntValue != nil {
		return false
	}
	if this.UintValue != nil && that1.UintValue != nil {
		if *this.UintValue != *that1.UintValue {
			return false
		}
	} else if this.UintValue != nil {
		return false
	} else if that1.UintValue != nil {
		return false
	}
	if this.BoolValue != nil && that1.BoolValue != nil {
		if *this.BoolValue != *that1.BoolValue {
			return false
		}
	} else if this.BoolValue != nil {
		return false
	} else if that1.BoolValue != nil {
		return false
	}
	if this.StringValue != nil && that1.StringValue != nil {
		if *this.StringValue != *that1.StringValue {
			return false
		}
	} else if this.StringValue != nil {
		return false
	} else if that1.StringValue != nil {
		return false
	}
	if !bytes.Equal(this.BytesValue, that1.BytesValue) {
		return false
	}
	return true
}
func (this *AnyName) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AnyName)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Underscore.Equal(that1.Underscore) {
		return false
	}
	return true
}
func (this *AnyNameExcept) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AnyNameExcept)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Exclamation.Equal(that1.Exclamation) {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.Except.Equal(that1.Except) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	return true
}
func (this *NameChoice) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NameChoice)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.Left.Equal(that1.Left) {
		return false
	}
	if !this.Pipe.Equal(that1.Pipe) {
		return false
	}
	if !this.Right.Equal(that1.Right) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	return true
}
func (this *Pattern) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Pattern)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Empty.Equal(that1.Empty) {
		return false
	}
	if !this.TreeNode.Equal(that1.TreeNode) {
		return false
	}
	if !this.LeafNode.Equal(that1.LeafNode) {
		return false
	}
	if !this.Concat.Equal(that1.Concat) {
		return false
	}
	if !this.Or.Equal(that1.Or) {
		return false
	}
	if !this.And.Equal(that1.And) {
		return false
	}
	if !this.ZeroOrMore.Equal(that1.ZeroOrMore) {
		return false
	}
	if !this.Reference.Equal(that1.Reference) {
		return false
	}
	if !this.Not.Equal(that1.Not) {
		return false
	}
	if !this.ZAny.Equal(that1.ZAny) {
		return false
	}
	if !this.Contains.Equal(that1.Contains) {
		return false
	}
	if !this.Optional.Equal(that1.Optional) {
		return false
	}
	if !this.Interleave.Equal(that1.Interleave) {
		return false
	}
	return true
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Empty)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Empty.Equal(that1.Empty) {
		return false
	}
	return true
}
func (this *TreeNode) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeNode)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Name.Equal(that1.Name) {
		return false
	}
	if !this.Colon.Equal(that1.Colon) {
		return false
	}
	if !this.Pattern.Equal(that1.Pattern) {
		return false
	}
	return true
}
func (this *Contains) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Contains)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Dot.Equal(that1.Dot) {
		return false
	}
	if !this.Pattern.Equal(that1.Pattern) {
		return false
	}
	return true
}
func (this *LeafNode) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LeafNode)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.RightArrow.Equal(that1.RightArrow) {
		return false
	}
	if !this.Expr.Equal(that1.Expr) {
		return false
	}
	return true
}
func (this *Concat) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Concat)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenBracket.Equal(that1.OpenBracket) {
		return false
	}
	if !this.LeftPattern.Equal(that1.LeftPattern) {
		return false
	}
	if !this.Comma.Equal(that1.Comma) {
		return false
	}
	if !this.RightPattern.Equal(that1.RightPattern) {
		return false
	}
	if !this.ExtraComma.Equal(that1.ExtraComma) {
		return false
	}
	if !this.CloseBracket.Equal(that1.CloseBracket) {
		return false
	}
	return true
}
func (this *Or) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Or)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.LeftPattern.Equal(that1.LeftPattern) {
		return false
	}
	if !this.Pipe.Equal(that1.Pipe) {
		return false
	}
	if !this.RightPattern.Equal(that1.RightPattern) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	return true
}
func (this *And) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*And)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.LeftPattern.Equal(that1.LeftPattern) {
		return false
	}
	if !this.Ampersand.Equal(that1.Ampersand) {
		return false
	}
	if !this.RightPattern.Equal(that1.RightPattern) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	return true
}
func (this *ZeroOrMore) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ZeroOrMore)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.Pattern.Equal(that1.Pattern) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	if !this.Star.Equal(that1.Star) {
		return false
	}
	return true
}
func (this *Reference) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Reference)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.At.Equal(that1.At) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Not) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Not)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Exclamation.Equal(that1.Exclamation) {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.Pattern.Equal(that1.Pattern) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	return true
}
func (this *ZAny) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ZAny)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Star.Equal(that1.Star) {
		return false
	}
	return true
}
func (this *Optional) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Optional)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.Pattern.Equal(that1.Pattern) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	if !this.QuestionMark.Equal(that1.QuestionMark) {
		return false
	}
	return true
}
func (this *Interleave) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Interleave)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenCurly.Equal(that1.OpenCurly) {
		return false
	}
	if !this.LeftPattern.Equal(that1.LeftPattern) {
		return false
	}
	if !this.SemiColon.Equal(that1.SemiColon) {
		return false
	}
	if !this.RightPattern.Equal(that1.RightPattern) {
		return false
	}
	if !this.ExtraSemiColon.Equal(that1.ExtraSemiColon) {
		return false
	}
	if !this.CloseCurly.Equal(that1.CloseCurly) {
		return false
	}
	return true
}
func (this *Grammar) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&relapse.Grammar{")
	if this.TopPattern != nil {
		s = append(s, "TopPattern: "+fmt.Sprintf("%#v", this.TopPattern)+",\n")
	}
	if this.PatternDecls != nil {
		s = append(s, "PatternDecls: "+fmt.Sprintf("%#v", this.PatternDecls)+",\n")
	}
	if this.After != nil {
		s = append(s, "After: "+fmt.Sprintf("%#v", this.After)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PatternDecl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&relapse.PatternDecl{")
	if this.Hash != nil {
		s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	}
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Eq != nil {
		s = append(s, "Eq: "+fmt.Sprintf("%#v", this.Eq)+",\n")
	}
	if this.Pattern != nil {
		s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NameExpr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&relapse.NameExpr{")
	if this.Name != nil {
		s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	}
	if this.AnyName != nil {
		s = append(s, "AnyName: "+fmt.Sprintf("%#v", this.AnyName)+",\n")
	}
	if this.AnyNameExcept != nil {
		s = append(s, "AnyNameExcept: "+fmt.Sprintf("%#v", this.AnyNameExcept)+",\n")
	}
	if this.NameChoice != nil {
		s = append(s, "NameChoice: "+fmt.Sprintf("%#v", this.NameChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Name) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&relapse.Name{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	if this.DoubleValue != nil {
		s = append(s, "DoubleValue: "+valueToGoStringRelapse(this.DoubleValue, "float64")+",\n")
	}
	if this.IntValue != nil {
		s = append(s, "IntValue: "+valueToGoStringRelapse(this.IntValue, "int64")+",\n")
	}
	if this.UintValue != nil {
		s = append(s, "UintValue: "+valueToGoStringRelapse(this.UintValue, "uint64")+",\n")
	}
	if this.BoolValue != nil {
		s = append(s, "BoolValue: "+valueToGoStringRelapse(this.BoolValue, "bool")+",\n")
	}
	if this.StringValue != nil {
		s = append(s, "StringValue: "+valueToGoStringRelapse(this.StringValue, "string")+",\n")
	}
	if this.BytesValue != nil {
		s = append(s, "BytesValue: "+valueToGoStringRelapse(this.BytesValue, "byte")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AnyName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&relapse.AnyName{")
	if this.Underscore != nil {
		s = append(s, "Underscore: "+fmt.Sprintf("%#v", this.Underscore)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AnyNameExcept) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&relapse.AnyNameExcept{")
	if this.Exclamation != nil {
		s = append(s, "Exclamation: "+fmt.Sprintf("%#v", this.Exclamation)+",\n")
	}
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.Except != nil {
		s = append(s, "Except: "+fmt.Sprintf("%#v", this.Except)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NameChoice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&relapse.NameChoice{")
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.Left != nil {
		s = append(s, "Left: "+fmt.Sprintf("%#v", this.Left)+",\n")
	}
	if this.Pipe != nil {
		s = append(s, "Pipe: "+fmt.Sprintf("%#v", this.Pipe)+",\n")
	}
	if this.Right != nil {
		s = append(s, "Right: "+fmt.Sprintf("%#v", this.Right)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Pattern) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&relapse.Pattern{")
	if this.Empty != nil {
		s = append(s, "Empty: "+fmt.Sprintf("%#v", this.Empty)+",\n")
	}
	if this.TreeNode != nil {
		s = append(s, "TreeNode: "+fmt.Sprintf("%#v", this.TreeNode)+",\n")
	}
	if this.LeafNode != nil {
		s = append(s, "LeafNode: "+fmt.Sprintf("%#v", this.LeafNode)+",\n")
	}
	if this.Concat != nil {
		s = append(s, "Concat: "+fmt.Sprintf("%#v", this.Concat)+",\n")
	}
	if this.Or != nil {
		s = append(s, "Or: "+fmt.Sprintf("%#v", this.Or)+",\n")
	}
	if this.And != nil {
		s = append(s, "And: "+fmt.Sprintf("%#v", this.And)+",\n")
	}
	if this.ZeroOrMore != nil {
		s = append(s, "ZeroOrMore: "+fmt.Sprintf("%#v", this.ZeroOrMore)+",\n")
	}
	if this.Reference != nil {
		s = append(s, "Reference: "+fmt.Sprintf("%#v", this.Reference)+",\n")
	}
	if this.Not != nil {
		s = append(s, "Not: "+fmt.Sprintf("%#v", this.Not)+",\n")
	}
	if this.ZAny != nil {
		s = append(s, "ZAny: "+fmt.Sprintf("%#v", this.ZAny)+",\n")
	}
	if this.Contains != nil {
		s = append(s, "Contains: "+fmt.Sprintf("%#v", this.Contains)+",\n")
	}
	if this.Optional != nil {
		s = append(s, "Optional: "+fmt.Sprintf("%#v", this.Optional)+",\n")
	}
	if this.Interleave != nil {
		s = append(s, "Interleave: "+fmt.Sprintf("%#v", this.Interleave)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&relapse.Empty{")
	if this.Empty != nil {
		s = append(s, "Empty: "+fmt.Sprintf("%#v", this.Empty)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TreeNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&relapse.TreeNode{")
	if this.Name != nil {
		s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	}
	if this.Colon != nil {
		s = append(s, "Colon: "+fmt.Sprintf("%#v", this.Colon)+",\n")
	}
	if this.Pattern != nil {
		s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Contains) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&relapse.Contains{")
	if this.Dot != nil {
		s = append(s, "Dot: "+fmt.Sprintf("%#v", this.Dot)+",\n")
	}
	if this.Pattern != nil {
		s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LeafNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&relapse.LeafNode{")
	if this.RightArrow != nil {
		s = append(s, "RightArrow: "+fmt.Sprintf("%#v", this.RightArrow)+",\n")
	}
	if this.Expr != nil {
		s = append(s, "Expr: "+fmt.Sprintf("%#v", this.Expr)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Concat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&relapse.Concat{")
	if this.OpenBracket != nil {
		s = append(s, "OpenBracket: "+fmt.Sprintf("%#v", this.OpenBracket)+",\n")
	}
	if this.LeftPattern != nil {
		s = append(s, "LeftPattern: "+fmt.Sprintf("%#v", this.LeftPattern)+",\n")
	}
	if this.Comma != nil {
		s = append(s, "Comma: "+fmt.Sprintf("%#v", this.Comma)+",\n")
	}
	if this.RightPattern != nil {
		s = append(s, "RightPattern: "+fmt.Sprintf("%#v", this.RightPattern)+",\n")
	}
	if this.ExtraComma != nil {
		s = append(s, "ExtraComma: "+fmt.Sprintf("%#v", this.ExtraComma)+",\n")
	}
	if this.CloseBracket != nil {
		s = append(s, "CloseBracket: "+fmt.Sprintf("%#v", this.CloseBracket)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Or) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&relapse.Or{")
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.LeftPattern != nil {
		s = append(s, "LeftPattern: "+fmt.Sprintf("%#v", this.LeftPattern)+",\n")
	}
	if this.Pipe != nil {
		s = append(s, "Pipe: "+fmt.Sprintf("%#v", this.Pipe)+",\n")
	}
	if this.RightPattern != nil {
		s = append(s, "RightPattern: "+fmt.Sprintf("%#v", this.RightPattern)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *And) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&relapse.And{")
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.LeftPattern != nil {
		s = append(s, "LeftPattern: "+fmt.Sprintf("%#v", this.LeftPattern)+",\n")
	}
	if this.Ampersand != nil {
		s = append(s, "Ampersand: "+fmt.Sprintf("%#v", this.Ampersand)+",\n")
	}
	if this.RightPattern != nil {
		s = append(s, "RightPattern: "+fmt.Sprintf("%#v", this.RightPattern)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ZeroOrMore) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&relapse.ZeroOrMore{")
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.Pattern != nil {
		s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	if this.Star != nil {
		s = append(s, "Star: "+fmt.Sprintf("%#v", this.Star)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Reference) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&relapse.Reference{")
	if this.At != nil {
		s = append(s, "At: "+fmt.Sprintf("%#v", this.At)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Not) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&relapse.Not{")
	if this.Exclamation != nil {
		s = append(s, "Exclamation: "+fmt.Sprintf("%#v", this.Exclamation)+",\n")
	}
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.Pattern != nil {
		s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ZAny) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&relapse.ZAny{")
	if this.Star != nil {
		s = append(s, "Star: "+fmt.Sprintf("%#v", this.Star)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Optional) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&relapse.Optional{")
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.Pattern != nil {
		s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	if this.QuestionMark != nil {
		s = append(s, "QuestionMark: "+fmt.Sprintf("%#v", this.QuestionMark)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Interleave) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&relapse.Interleave{")
	if this.OpenCurly != nil {
		s = append(s, "OpenCurly: "+fmt.Sprintf("%#v", this.OpenCurly)+",\n")
	}
	if this.LeftPattern != nil {
		s = append(s, "LeftPattern: "+fmt.Sprintf("%#v", this.LeftPattern)+",\n")
	}
	if this.SemiColon != nil {
		s = append(s, "SemiColon: "+fmt.Sprintf("%#v", this.SemiColon)+",\n")
	}
	if this.RightPattern != nil {
		s = append(s, "RightPattern: "+fmt.Sprintf("%#v", this.RightPattern)+",\n")
	}
	if this.ExtraSemiColon != nil {
		s = append(s, "ExtraSemiColon: "+fmt.Sprintf("%#v", this.ExtraSemiColon)+",\n")
	}
	if this.CloseCurly != nil {
		s = append(s, "CloseCurly: "+fmt.Sprintf("%#v", this.CloseCurly)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringRelapse(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringRelapse(e map[int32]github_com_gogo_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func (m *Grammar) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Grammar) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopPattern != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.TopPattern.Size()))
		n1, err := m.TopPattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.PatternDecls) > 0 {
		for _, msg := range m.PatternDecls {
			data[i] = 0x12
			i++
			i = encodeVarintRelapse(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.After != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.After.Size()))
		n2, err := m.After.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *PatternDecl) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PatternDecl) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hash != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Hash.Size()))
		n3, err := m.Hash.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Before != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Before.Size()))
		n4, err := m.Before.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	data[i] = 0x1a
	i++
	i = encodeVarintRelapse(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	if m.Eq != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Eq.Size()))
		n5, err := m.Eq.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Pattern != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Pattern.Size()))
		n6, err := m.Pattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *NameExpr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NameExpr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Name.Size()))
		n7, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.AnyName != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.AnyName.Size()))
		n8, err := m.AnyName.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.AnyNameExcept != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.AnyNameExcept.Size()))
		n9, err := m.AnyNameExcept.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.NameChoice != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRelapse(data, i, uint64(m.NameChoice.Size()))
		n10, err := m.NameChoice.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *Name) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Name) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Before.Size()))
		n11, err := m.Before.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.DoubleValue != nil {
		data[i] = 0x19
		i++
		i = encodeFixed64Relapse(data, i, uint64(math.Float64bits(*m.DoubleValue)))
	}
	if m.IntValue != nil {
		data[i] = 0x28
		i++
		i = encodeVarintRelapse(data, i, uint64(*m.IntValue))
	}
	if m.UintValue != nil {
		data[i] = 0x30
		i++
		i = encodeVarintRelapse(data, i, uint64(*m.UintValue))
	}
	if m.BoolValue != nil {
		data[i] = 0x40
		i++
		if *m.BoolValue {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.StringValue != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintRelapse(data, i, uint64(len(*m.StringValue)))
		i += copy(data[i:], *m.StringValue)
	}
	if m.BytesValue != nil {
		data[i] = 0x52
		i++
		i = encodeVarintRelapse(data, i, uint64(len(m.BytesValue)))
		i += copy(data[i:], m.BytesValue)
	}
	return i, nil
}

func (m *AnyName) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AnyName) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Underscore != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Underscore.Size()))
		n12, err := m.Underscore.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *AnyNameExcept) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AnyNameExcept) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exclamation != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Exclamation.Size()))
		n13, err := m.Exclamation.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.OpenParen != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.OpenParen.Size()))
		n14, err := m.OpenParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Except != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Except.Size()))
		n15, err := m.Except.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.CloseParen != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRelapse(data, i, uint64(m.CloseParen.Size()))
		n16, err := m.CloseParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *NameChoice) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NameChoice) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.OpenParen.Size()))
		n17, err := m.OpenParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Left != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Left.Size()))
		n18, err := m.Left.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Pipe != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Pipe.Size()))
		n19, err := m.Pipe.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Right != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Right.Size()))
		n20, err := m.Right.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.CloseParen != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.CloseParen.Size()))
		n21, err := m.CloseParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *Pattern) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Pattern) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Empty != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Empty.Size()))
		n22, err := m.Empty.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.TreeNode != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.TreeNode.Size()))
		n23, err := m.TreeNode.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.LeafNode != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRelapse(data, i, uint64(m.LeafNode.Size()))
		n24, err := m.LeafNode.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Concat != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Concat.Size()))
		n25, err := m.Concat.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Or != nil {
		data[i] = 0x32
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Or.Size()))
		n26, err := m.Or.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.And != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.And.Size()))
		n27, err := m.And.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.ZeroOrMore != nil {
		data[i] = 0x42
		i++
		i = encodeVarintRelapse(data, i, uint64(m.ZeroOrMore.Size()))
		n28, err := m.ZeroOrMore.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Reference != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Reference.Size()))
		n29, err := m.Reference.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Not != nil {
		data[i] = 0x52
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Not.Size()))
		n30, err := m.Not.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.ZAny != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.ZAny.Size()))
		n31, err := m.ZAny.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Contains != nil {
		data[i] = 0x62
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Contains.Size()))
		n32, err := m.Contains.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Optional != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Optional.Size()))
		n33, err := m.Optional.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Interleave != nil {
		data[i] = 0x72
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Interleave.Size()))
		n34, err := m.Interleave.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}

func (m *Empty) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Empty) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Empty != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Empty.Size()))
		n35, err := m.Empty.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *TreeNode) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TreeNode) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Name.Size()))
		n36, err := m.Name.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Colon != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Colon.Size()))
		n37, err := m.Colon.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.Pattern != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Pattern.Size()))
		n38, err := m.Pattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *Contains) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Contains) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dot != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Dot.Size()))
		n39, err := m.Dot.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Pattern != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Pattern.Size()))
		n40, err := m.Pattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *LeafNode) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LeafNode) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RightArrow != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.RightArrow.Size()))
		n41, err := m.RightArrow.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Expr != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Expr.Size()))
		n42, err := m.Expr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *Concat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Concat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenBracket != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.OpenBracket.Size()))
		n43, err := m.OpenBracket.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.LeftPattern != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.LeftPattern.Size()))
		n44, err := m.LeftPattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.Comma != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Comma.Size()))
		n45, err := m.Comma.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.RightPattern != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.RightPattern.Size()))
		n46, err := m.RightPattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.ExtraComma != nil {
		data[i] = 0x32
		i++
		i = encodeVarintRelapse(data, i, uint64(m.ExtraComma.Size()))
		n47, err := m.ExtraComma.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.CloseBracket != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.CloseBracket.Size()))
		n48, err := m.CloseBracket.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}

func (m *Or) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Or) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.OpenParen.Size()))
		n49, err := m.OpenParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.LeftPattern != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.LeftPattern.Size()))
		n50, err := m.LeftPattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.Pipe != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Pipe.Size()))
		n51, err := m.Pipe.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.RightPattern != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRelapse(data, i, uint64(m.RightPattern.Size()))
		n52, err := m.RightPattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.CloseParen != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.CloseParen.Size()))
		n53, err := m.CloseParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	return i, nil
}

func (m *And) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *And) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.OpenParen.Size()))
		n54, err := m.OpenParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.LeftPattern != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.LeftPattern.Size()))
		n55, err := m.LeftPattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.Ampersand != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Ampersand.Size()))
		n56, err := m.Ampersand.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.RightPattern != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRelapse(data, i, uint64(m.RightPattern.Size()))
		n57, err := m.RightPattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.CloseParen != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.CloseParen.Size()))
		n58, err := m.CloseParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}

func (m *ZeroOrMore) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ZeroOrMore) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.OpenParen.Size()))
		n59, err := m.OpenParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.Pattern != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Pattern.Size()))
		n60, err := m.Pattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.CloseParen != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.CloseParen.Size()))
		n61, err := m.CloseParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.Star != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Star.Size()))
		n62, err := m.Star.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}

func (m *Reference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Reference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.At != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.At.Size()))
		n63, err := m.At.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	data[i] = 0x12
	i++
	i = encodeVarintRelapse(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	return i, nil
}

func (m *Not) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Not) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exclamation != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Exclamation.Size()))
		n64, err := m.Exclamation.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.OpenParen != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.OpenParen.Size()))
		n65, err := m.OpenParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.Pattern != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Pattern.Size()))
		n66, err := m.Pattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.CloseParen != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRelapse(data, i, uint64(m.CloseParen.Size()))
		n67, err := m.CloseParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}

func (m *ZAny) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ZAny) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Star != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Star.Size()))
		n68, err := m.Star.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}

func (m *Optional) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Optional) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRelapse(data, i, uint64(m.OpenParen.Size()))
		n69, err := m.OpenParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.Pattern != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.Pattern.Size()))
		n70, err := m.Pattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.CloseParen != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.CloseParen.Size()))
		n71, err := m.CloseParen.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if m.QuestionMark != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRelapse(data, i, uint64(m.QuestionMark.Size()))
		n72, err := m.QuestionMark.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	return i, nil
}

func (m *Interleave) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Interleave) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenCurly != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRelapse(data, i, uint64(m.OpenCurly.Size()))
		n73, err := m.OpenCurly.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if m.LeftPattern != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.LeftPattern.Size()))
		n74, err := m.LeftPattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.SemiColon != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRelapse(data, i, uint64(m.SemiColon.Size()))
		n75, err := m.SemiColon.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if m.RightPattern != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.RightPattern.Size()))
		n76, err := m.RightPattern.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if m.ExtraSemiColon != nil {
		data[i] = 0x32
		i++
		i = encodeVarintRelapse(data, i, uint64(m.ExtraSemiColon.Size()))
		n77, err := m.ExtraSemiColon.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	if m.CloseCurly != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintRelapse(data, i, uint64(m.CloseCurly.Size()))
		n78, err := m.CloseCurly.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}

func encodeFixed64Relapse(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Relapse(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRelapse(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Grammar) Size() (n int) {
	var l int
	_ = l
	if m.TopPattern != nil {
		l = m.TopPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if len(m.PatternDecls) > 0 {
		for _, e := range m.PatternDecls {
			l = e.Size()
			n += 1 + l + sovRelapse(uint64(l))
		}
	}
	if m.After != nil {
		l = m.After.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *PatternDecl) Size() (n int) {
	var l int
	_ = l
	if m.Hash != nil {
		l = m.Hash.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	l = len(m.Name)
	n += 1 + l + sovRelapse(uint64(l))
	if m.Eq != nil {
		l = m.Eq.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *NameExpr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.AnyName != nil {
		l = m.AnyName.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.AnyNameExcept != nil {
		l = m.AnyNameExcept.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.NameChoice != nil {
		l = m.NameChoice.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Name) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.DoubleValue != nil {
		n += 9
	}
	if m.IntValue != nil {
		n += 1 + sovRelapse(uint64(*m.IntValue))
	}
	if m.UintValue != nil {
		n += 1 + sovRelapse(uint64(*m.UintValue))
	}
	if m.BoolValue != nil {
		n += 2
	}
	if m.StringValue != nil {
		l = len(*m.StringValue)
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.BytesValue != nil {
		l = len(m.BytesValue)
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *AnyName) Size() (n int) {
	var l int
	_ = l
	if m.Underscore != nil {
		l = m.Underscore.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *AnyNameExcept) Size() (n int) {
	var l int
	_ = l
	if m.Exclamation != nil {
		l = m.Exclamation.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Except != nil {
		l = m.Except.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *NameChoice) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pipe != nil {
		l = m.Pipe.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Pattern) Size() (n int) {
	var l int
	_ = l
	if m.Empty != nil {
		l = m.Empty.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.TreeNode != nil {
		l = m.TreeNode.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeafNode != nil {
		l = m.LeafNode.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Concat != nil {
		l = m.Concat.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Or != nil {
		l = m.Or.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.And != nil {
		l = m.And.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.ZeroOrMore != nil {
		l = m.ZeroOrMore.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Reference != nil {
		l = m.Reference.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Not != nil {
		l = m.Not.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.ZAny != nil {
		l = m.ZAny.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Contains != nil {
		l = m.Contains.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Optional != nil {
		l = m.Optional.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Interleave != nil {
		l = m.Interleave.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	if m.Empty != nil {
		l = m.Empty.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *TreeNode) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Colon != nil {
		l = m.Colon.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Contains) Size() (n int) {
	var l int
	_ = l
	if m.Dot != nil {
		l = m.Dot.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *LeafNode) Size() (n int) {
	var l int
	_ = l
	if m.RightArrow != nil {
		l = m.RightArrow.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Concat) Size() (n int) {
	var l int
	_ = l
	if m.OpenBracket != nil {
		l = m.OpenBracket.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeftPattern != nil {
		l = m.LeftPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Comma != nil {
		l = m.Comma.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.RightPattern != nil {
		l = m.RightPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.ExtraComma != nil {
		l = m.ExtraComma.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseBracket != nil {
		l = m.CloseBracket.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Or) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeftPattern != nil {
		l = m.LeftPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pipe != nil {
		l = m.Pipe.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.RightPattern != nil {
		l = m.RightPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *And) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeftPattern != nil {
		l = m.LeftPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Ampersand != nil {
		l = m.Ampersand.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.RightPattern != nil {
		l = m.RightPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *ZeroOrMore) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Star != nil {
		l = m.Star.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Reference) Size() (n int) {
	var l int
	_ = l
	if m.At != nil {
		l = m.At.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	l = len(m.Name)
	n += 1 + l + sovRelapse(uint64(l))
	return n
}

func (m *Not) Size() (n int) {
	var l int
	_ = l
	if m.Exclamation != nil {
		l = m.Exclamation.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *ZAny) Size() (n int) {
	var l int
	_ = l
	if m.Star != nil {
		l = m.Star.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Optional) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.QuestionMark != nil {
		l = m.QuestionMark.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Interleave) Size() (n int) {
	var l int
	_ = l
	if m.OpenCurly != nil {
		l = m.OpenCurly.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeftPattern != nil {
		l = m.LeftPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.SemiColon != nil {
		l = m.SemiColon.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.RightPattern != nil {
		l = m.RightPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.ExtraSemiColon != nil {
		l = m.ExtraSemiColon.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseCurly != nil {
		l = m.CloseCurly.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func sovRelapse(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRelapse(x uint64) (n int) {
	return sovRelapse(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NameExpr) GetValue() interface{} {
	if this.Name != nil {
		return this.Name
	}
	if this.AnyName != nil {
		return this.AnyName
	}
	if this.AnyNameExcept != nil {
		return this.AnyNameExcept
	}
	if this.NameChoice != nil {
		return this.NameChoice
	}
	return nil
}

func (this *NameExpr) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *Name:
		this.Name = vt
	case *AnyName:
		this.AnyName = vt
	case *AnyNameExcept:
		this.AnyNameExcept = vt
	case *NameChoice:
		this.NameChoice = vt
	default:
		return false
	}
	return true
}
func (this *Pattern) GetValue() interface{} {
	if this.Empty != nil {
		return this.Empty
	}
	if this.TreeNode != nil {
		return this.TreeNode
	}
	if this.LeafNode != nil {
		return this.LeafNode
	}
	if this.Concat != nil {
		return this.Concat
	}
	if this.Or != nil {
		return this.Or
	}
	if this.And != nil {
		return this.And
	}
	if this.ZeroOrMore != nil {
		return this.ZeroOrMore
	}
	if this.Reference != nil {
		return this.Reference
	}
	if this.Not != nil {
		return this.Not
	}
	if this.ZAny != nil {
		return this.ZAny
	}
	if this.Contains != nil {
		return this.Contains
	}
	if this.Optional != nil {
		return this.Optional
	}
	if this.Interleave != nil {
		return this.Interleave
	}
	return nil
}

func (this *Pattern) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *Empty:
		this.Empty = vt
	case *TreeNode:
		this.TreeNode = vt
	case *LeafNode:
		this.LeafNode = vt
	case *Concat:
		this.Concat = vt
	case *Or:
		this.Or = vt
	case *And:
		this.And = vt
	case *ZeroOrMore:
		this.ZeroOrMore = vt
	case *Reference:
		this.Reference = vt
	case *Not:
		this.Not = vt
	case *ZAny:
		this.ZAny = vt
	case *Contains:
		this.Contains = vt
	case *Optional:
		this.Optional = vt
	case *Interleave:
		this.Interleave = vt
	default:
		return false
	}
	return true
}
func (m *Grammar) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grammar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grammar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopPattern == nil {
				m.TopPattern = &Pattern{}
			}
			if err := m.TopPattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatternDecls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternDecls = append(m.PatternDecls, &PatternDecl{})
			if err := m.PatternDecls[len(m.PatternDecls)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.After == nil {
				m.After = &expr.Space{}
			}
			if err := m.After.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatternDecl) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatternDecl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatternDecl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hash == nil {
				m.Hash = &expr.Keyword{}
			}
			if err := m.Hash.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &expr.Space{}
			}
			if err := m.Before.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Eq == nil {
				m.Eq = &expr.Keyword{}
			}
			if err := m.Eq.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NameExpr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &Name{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnyName == nil {
				m.AnyName = &AnyName{}
			}
			if err := m.AnyName.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyNameExcept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnyNameExcept == nil {
				m.AnyNameExcept = &AnyNameExcept{}
			}
			if err := m.AnyNameExcept.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameChoice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NameChoice == nil {
				m.NameChoice = &NameChoice{}
			}
			if err := m.NameChoice.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Name) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Name: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Name: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &expr.Space{}
			}
			if err := m.Before.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.DoubleValue = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntValue = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UintValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UintValue = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BoolValue = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.StringValue = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesValue = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnyName) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Underscore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Underscore == nil {
				m.Underscore = &expr.Keyword{}
			}
			if err := m.Underscore.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnyNameExcept) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyNameExcept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyNameExcept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclamation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Exclamation == nil {
				m.Exclamation = &expr.Keyword{}
			}
			if err := m.Exclamation.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &expr.Keyword{}
			}
			if err := m.OpenParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Except", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Except == nil {
				m.Except = &NameExpr{}
			}
			if err := m.Except.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &expr.Keyword{}
			}
			if err := m.CloseParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NameChoice) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &expr.Keyword{}
			}
			if err := m.OpenParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &NameExpr{}
			}
			if err := m.Left.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipe == nil {
				m.Pipe = &expr.Keyword{}
			}
			if err := m.Pipe.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &NameExpr{}
			}
			if err := m.Right.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &expr.Keyword{}
			}
			if err := m.CloseParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pattern) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Empty == nil {
				m.Empty = &Empty{}
			}
			if err := m.Empty.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreeNode == nil {
				m.TreeNode = &TreeNode{}
			}
			if err := m.TreeNode.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeafNode == nil {
				m.LeafNode = &LeafNode{}
			}
			if err := m.LeafNode.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Concat == nil {
				m.Concat = &Concat{}
			}
			if err := m.Concat.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Or", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Or == nil {
				m.Or = &Or{}
			}
			if err := m.Or.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field And", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.And == nil {
				m.And = &And{}
			}
			if err := m.And.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroOrMore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZeroOrMore == nil {
				m.ZeroOrMore = &ZeroOrMore{}
			}
			if err := m.ZeroOrMore.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reference == nil {
				m.Reference = &Reference{}
			}
			if err := m.Reference.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Not", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Not == nil {
				m.Not = &Not{}
			}
			if err := m.Not.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZAny", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZAny == nil {
				m.ZAny = &ZAny{}
			}
			if err := m.ZAny.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contains == nil {
				m.Contains = &Contains{}
			}
			if err := m.Contains.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Optional", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Optional == nil {
				m.Optional = &Optional{}
			}
			if err := m.Optional.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interleave", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interleave == nil {
				m.Interleave = &Interleave{}
			}
			if err := m.Interleave.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Empty == nil {
				m.Empty = &expr.Keyword{}
			}
			if err := m.Empty.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeNode) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &NameExpr{}
			}
			if err := m.Name.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Colon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Colon == nil {
				m.Colon = &expr.Keyword{}
			}
			if err := m.Colon.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contains) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contains: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contains: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dot == nil {
				m.Dot = &expr.Keyword{}
			}
			if err := m.Dot.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafNode) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeafNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeafNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightArrow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightArrow == nil {
				m.RightArrow = &expr.Keyword{}
			}
			if err := m.RightArrow.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &expr.Expr{}
			}
			if err := m.Expr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Concat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Concat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Concat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenBracket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenBracket == nil {
				m.OpenBracket = &expr.Keyword{}
			}
			if err := m.OpenBracket.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftPattern == nil {
				m.LeftPattern = &Pattern{}
			}
			if err := m.LeftPattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comma", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Comma == nil {
				m.Comma = &expr.Keyword{}
			}
			if err := m.Comma.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightPattern == nil {
				m.RightPattern = &Pattern{}
			}
			if err := m.RightPattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraComma", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraComma == nil {
				m.ExtraComma = &expr.Keyword{}
			}
			if err := m.ExtraComma.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseBracket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseBracket == nil {
				m.CloseBracket = &expr.Keyword{}
			}
			if err := m.CloseBracket.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Or) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Or: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Or: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &expr.Keyword{}
			}
			if err := m.OpenParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftPattern == nil {
				m.LeftPattern = &Pattern{}
			}
			if err := m.LeftPattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipe == nil {
				m.Pipe = &expr.Keyword{}
			}
			if err := m.Pipe.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightPattern == nil {
				m.RightPattern = &Pattern{}
			}
			if err := m.RightPattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &expr.Keyword{}
			}
			if err := m.CloseParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *And) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: And: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: And: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &expr.Keyword{}
			}
			if err := m.OpenParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftPattern == nil {
				m.LeftPattern = &Pattern{}
			}
			if err := m.LeftPattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ampersand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ampersand == nil {
				m.Ampersand = &expr.Keyword{}
			}
			if err := m.Ampersand.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightPattern == nil {
				m.RightPattern = &Pattern{}
			}
			if err := m.RightPattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &expr.Keyword{}
			}
			if err := m.CloseParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroOrMore) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroOrMore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroOrMore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &expr.Keyword{}
			}
			if err := m.OpenParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &expr.Keyword{}
			}
			if err := m.CloseParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Star == nil {
				m.Star = &expr.Keyword{}
			}
			if err := m.Star.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field At", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.At == nil {
				m.At = &expr.Keyword{}
			}
			if err := m.At.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Not) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Not: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Not: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclamation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Exclamation == nil {
				m.Exclamation = &expr.Keyword{}
			}
			if err := m.Exclamation.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &expr.Keyword{}
			}
			if err := m.OpenParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &expr.Keyword{}
			}
			if err := m.CloseParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZAny) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZAny: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZAny: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Star == nil {
				m.Star = &expr.Keyword{}
			}
			if err := m.Star.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Optional) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Optional: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Optional: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &expr.Keyword{}
			}
			if err := m.OpenParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &expr.Keyword{}
			}
			if err := m.CloseParen.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestionMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuestionMark == nil {
				m.QuestionMark = &expr.Keyword{}
			}
			if err := m.QuestionMark.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interleave) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interleave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interleave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenCurly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenCurly == nil {
				m.OpenCurly = &expr.Keyword{}
			}
			if err := m.OpenCurly.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftPattern == nil {
				m.LeftPattern = &Pattern{}
			}
			if err := m.LeftPattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemiColon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SemiColon == nil {
				m.SemiColon = &expr.Keyword{}
			}
			if err := m.SemiColon.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightPattern == nil {
				m.RightPattern = &Pattern{}
			}
			if err := m.RightPattern.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraSemiColon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraSemiColon == nil {
				m.ExtraSemiColon = &expr.Keyword{}
			}
			if err := m.ExtraSemiColon.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseCurly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseCurly == nil {
				m.CloseCurly = &expr.Keyword{}
			}
			if err := m.CloseCurly.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRelapse(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRelapse
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRelapse
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRelapse(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRelapse = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRelapse   = fmt.Errorf("proto: integer overflow")
)
