// Code generated by protoc-gen-gogo.
// source: relapse.proto
// DO NOT EDIT!

/*
	Package relapse is a generated protocol buffer package.

	It is generated from these files:
		relapse.proto

	It has these top-level messages:
		Grammar
		PatternDecl
		NameExpr
		Name
		AnyName
		AnyNameExcept
		NameChoice
		Pattern
		Empty
		TreeNode
		Contains
		LeafNode
		Concat
		Or
		And
		ZeroOrMore
		Reference
		Not
		ZAny
		Optional
		Interleave
*/
package relapse

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import expr "github.com/katydid/katydid/expr/ast"

import bytes "bytes"

import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Grammar struct {
	TopPattern   *Pattern       `protobuf:"bytes,1,opt,name=TopPattern" json:"TopPattern,omitempty"`
	PatternDecls []*PatternDecl `protobuf:"bytes,2,rep,name=PatternDecls" json:"PatternDecls,omitempty"`
	After        *expr.Space    `protobuf:"bytes,3,opt,name=After" json:"After,omitempty"`
}

func (m *Grammar) Reset()      { *m = Grammar{} }
func (*Grammar) ProtoMessage() {}

func (m *Grammar) GetTopPattern() *Pattern {
	if m != nil {
		return m.TopPattern
	}
	return nil
}

func (m *Grammar) GetPatternDecls() []*PatternDecl {
	if m != nil {
		return m.PatternDecls
	}
	return nil
}

func (m *Grammar) GetAfter() *expr.Space {
	if m != nil {
		return m.After
	}
	return nil
}

type PatternDecl struct {
	Hash    *expr.Keyword `protobuf:"bytes,1,opt,name=Hash" json:"Hash,omitempty"`
	Before  *expr.Space   `protobuf:"bytes,2,opt,name=Before" json:"Before,omitempty"`
	Name    string        `protobuf:"bytes,3,opt,name=Name" json:"Name"`
	Eq      *expr.Keyword `protobuf:"bytes,4,opt,name=Eq" json:"Eq,omitempty"`
	Pattern *Pattern      `protobuf:"bytes,5,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *PatternDecl) Reset()      { *m = PatternDecl{} }
func (*PatternDecl) ProtoMessage() {}

func (m *PatternDecl) GetHash() *expr.Keyword {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *PatternDecl) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *PatternDecl) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PatternDecl) GetEq() *expr.Keyword {
	if m != nil {
		return m.Eq
	}
	return nil
}

func (m *PatternDecl) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

type NameExpr struct {
	Name          *Name          `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	AnyName       *AnyName       `protobuf:"bytes,2,opt,name=AnyName" json:"AnyName,omitempty"`
	AnyNameExcept *AnyNameExcept `protobuf:"bytes,3,opt,name=AnyNameExcept" json:"AnyNameExcept,omitempty"`
	NameChoice    *NameChoice    `protobuf:"bytes,4,opt,name=NameChoice" json:"NameChoice,omitempty"`
}

func (m *NameExpr) Reset()      { *m = NameExpr{} }
func (*NameExpr) ProtoMessage() {}

func (m *NameExpr) GetName() *Name {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *NameExpr) GetAnyName() *AnyName {
	if m != nil {
		return m.AnyName
	}
	return nil
}

func (m *NameExpr) GetAnyNameExcept() *AnyNameExcept {
	if m != nil {
		return m.AnyNameExcept
	}
	return nil
}

func (m *NameExpr) GetNameChoice() *NameChoice {
	if m != nil {
		return m.NameChoice
	}
	return nil
}

type Name struct {
	Before      *expr.Space `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	DoubleValue *float64    `protobuf:"fixed64,3,opt,name=DoubleValue" json:"DoubleValue,omitempty"`
	IntValue    *int64      `protobuf:"varint,5,opt,name=IntValue" json:"IntValue,omitempty"`
	UintValue   *uint64     `protobuf:"varint,6,opt,name=UintValue" json:"UintValue,omitempty"`
	BoolValue   *bool       `protobuf:"varint,8,opt,name=BoolValue" json:"BoolValue,omitempty"`
	StringValue *string     `protobuf:"bytes,9,opt,name=StringValue" json:"StringValue,omitempty"`
	BytesValue  []byte      `protobuf:"bytes,10,opt,name=BytesValue" json:"BytesValue,omitempty"`
}

func (m *Name) Reset()      { *m = Name{} }
func (*Name) ProtoMessage() {}

func (m *Name) GetBefore() *expr.Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Name) GetDoubleValue() float64 {
	if m != nil && m.DoubleValue != nil {
		return *m.DoubleValue
	}
	return 0
}

func (m *Name) GetIntValue() int64 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *Name) GetUintValue() uint64 {
	if m != nil && m.UintValue != nil {
		return *m.UintValue
	}
	return 0
}

func (m *Name) GetBoolValue() bool {
	if m != nil && m.BoolValue != nil {
		return *m.BoolValue
	}
	return false
}

func (m *Name) GetStringValue() string {
	if m != nil && m.StringValue != nil {
		return *m.StringValue
	}
	return ""
}

func (m *Name) GetBytesValue() []byte {
	if m != nil {
		return m.BytesValue
	}
	return nil
}

type AnyName struct {
	Underscore *expr.Keyword `protobuf:"bytes,1,opt,name=Underscore" json:"Underscore,omitempty"`
}

func (m *AnyName) Reset()      { *m = AnyName{} }
func (*AnyName) ProtoMessage() {}

func (m *AnyName) GetUnderscore() *expr.Keyword {
	if m != nil {
		return m.Underscore
	}
	return nil
}

type AnyNameExcept struct {
	Exclamation *expr.Keyword `protobuf:"bytes,1,opt,name=Exclamation" json:"Exclamation,omitempty"`
	OpenParen   *expr.Keyword `protobuf:"bytes,2,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Except      *NameExpr     `protobuf:"bytes,3,opt,name=Except" json:"Except,omitempty"`
	CloseParen  *expr.Keyword `protobuf:"bytes,4,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *AnyNameExcept) Reset()      { *m = AnyNameExcept{} }
func (*AnyNameExcept) ProtoMessage() {}

func (m *AnyNameExcept) GetExclamation() *expr.Keyword {
	if m != nil {
		return m.Exclamation
	}
	return nil
}

func (m *AnyNameExcept) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *AnyNameExcept) GetExcept() *NameExpr {
	if m != nil {
		return m.Except
	}
	return nil
}

func (m *AnyNameExcept) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type NameChoice struct {
	OpenParen  *expr.Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Left       *NameExpr     `protobuf:"bytes,2,opt,name=Left" json:"Left,omitempty"`
	Pipe       *expr.Keyword `protobuf:"bytes,3,opt,name=Pipe" json:"Pipe,omitempty"`
	Right      *NameExpr     `protobuf:"bytes,4,opt,name=Right" json:"Right,omitempty"`
	CloseParen *expr.Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *NameChoice) Reset()      { *m = NameChoice{} }
func (*NameChoice) ProtoMessage() {}

func (m *NameChoice) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *NameChoice) GetLeft() *NameExpr {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *NameChoice) GetPipe() *expr.Keyword {
	if m != nil {
		return m.Pipe
	}
	return nil
}

func (m *NameChoice) GetRight() *NameExpr {
	if m != nil {
		return m.Right
	}
	return nil
}

func (m *NameChoice) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type Pattern struct {
	Empty      *Empty      `protobuf:"bytes,1,opt,name=Empty" json:"Empty,omitempty"`
	TreeNode   *TreeNode   `protobuf:"bytes,3,opt,name=TreeNode" json:"TreeNode,omitempty"`
	LeafNode   *LeafNode   `protobuf:"bytes,4,opt,name=LeafNode" json:"LeafNode,omitempty"`
	Concat     *Concat     `protobuf:"bytes,5,opt,name=Concat" json:"Concat,omitempty"`
	Or         *Or         `protobuf:"bytes,6,opt,name=Or" json:"Or,omitempty"`
	And        *And        `protobuf:"bytes,7,opt,name=And" json:"And,omitempty"`
	ZeroOrMore *ZeroOrMore `protobuf:"bytes,8,opt,name=ZeroOrMore" json:"ZeroOrMore,omitempty"`
	Reference  *Reference  `protobuf:"bytes,9,opt,name=Reference" json:"Reference,omitempty"`
	Not        *Not        `protobuf:"bytes,10,opt,name=Not" json:"Not,omitempty"`
	ZAny       *ZAny       `protobuf:"bytes,11,opt,name=ZAny" json:"ZAny,omitempty"`
	Contains   *Contains   `protobuf:"bytes,12,opt,name=Contains" json:"Contains,omitempty"`
	Optional   *Optional   `protobuf:"bytes,13,opt,name=Optional" json:"Optional,omitempty"`
	Interleave *Interleave `protobuf:"bytes,14,opt,name=Interleave" json:"Interleave,omitempty"`
}

func (m *Pattern) Reset()      { *m = Pattern{} }
func (*Pattern) ProtoMessage() {}

func (m *Pattern) GetEmpty() *Empty {
	if m != nil {
		return m.Empty
	}
	return nil
}

func (m *Pattern) GetTreeNode() *TreeNode {
	if m != nil {
		return m.TreeNode
	}
	return nil
}

func (m *Pattern) GetLeafNode() *LeafNode {
	if m != nil {
		return m.LeafNode
	}
	return nil
}

func (m *Pattern) GetConcat() *Concat {
	if m != nil {
		return m.Concat
	}
	return nil
}

func (m *Pattern) GetOr() *Or {
	if m != nil {
		return m.Or
	}
	return nil
}

func (m *Pattern) GetAnd() *And {
	if m != nil {
		return m.And
	}
	return nil
}

func (m *Pattern) GetZeroOrMore() *ZeroOrMore {
	if m != nil {
		return m.ZeroOrMore
	}
	return nil
}

func (m *Pattern) GetReference() *Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *Pattern) GetNot() *Not {
	if m != nil {
		return m.Not
	}
	return nil
}

func (m *Pattern) GetZAny() *ZAny {
	if m != nil {
		return m.ZAny
	}
	return nil
}

func (m *Pattern) GetContains() *Contains {
	if m != nil {
		return m.Contains
	}
	return nil
}

func (m *Pattern) GetOptional() *Optional {
	if m != nil {
		return m.Optional
	}
	return nil
}

func (m *Pattern) GetInterleave() *Interleave {
	if m != nil {
		return m.Interleave
	}
	return nil
}

type Empty struct {
	Empty *expr.Keyword `protobuf:"bytes,1,opt,name=Empty" json:"Empty,omitempty"`
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}

func (m *Empty) GetEmpty() *expr.Keyword {
	if m != nil {
		return m.Empty
	}
	return nil
}

type TreeNode struct {
	Name    *NameExpr     `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Colon   *expr.Keyword `protobuf:"bytes,2,opt,name=Colon" json:"Colon,omitempty"`
	Pattern *Pattern      `protobuf:"bytes,3,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *TreeNode) Reset()      { *m = TreeNode{} }
func (*TreeNode) ProtoMessage() {}

func (m *TreeNode) GetName() *NameExpr {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *TreeNode) GetColon() *expr.Keyword {
	if m != nil {
		return m.Colon
	}
	return nil
}

func (m *TreeNode) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

type Contains struct {
	Dot     *expr.Keyword `protobuf:"bytes,1,opt,name=Dot" json:"Dot,omitempty"`
	Pattern *Pattern      `protobuf:"bytes,2,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *Contains) Reset()      { *m = Contains{} }
func (*Contains) ProtoMessage() {}

func (m *Contains) GetDot() *expr.Keyword {
	if m != nil {
		return m.Dot
	}
	return nil
}

func (m *Contains) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

type LeafNode struct {
	RightArrow *expr.Keyword `protobuf:"bytes,1,opt,name=RightArrow" json:"RightArrow,omitempty"`
	Expr       *expr.Expr    `protobuf:"bytes,2,opt,name=Expr" json:"Expr,omitempty"`
}

func (m *LeafNode) Reset()      { *m = LeafNode{} }
func (*LeafNode) ProtoMessage() {}

func (m *LeafNode) GetRightArrow() *expr.Keyword {
	if m != nil {
		return m.RightArrow
	}
	return nil
}

func (m *LeafNode) GetExpr() *expr.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

type Concat struct {
	OpenBracket  *expr.Keyword `protobuf:"bytes,2,opt,name=OpenBracket" json:"OpenBracket,omitempty"`
	LeftPattern  *Pattern      `protobuf:"bytes,3,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	Comma        *expr.Keyword `protobuf:"bytes,4,opt,name=Comma" json:"Comma,omitempty"`
	RightPattern *Pattern      `protobuf:"bytes,5,opt,name=RightPattern" json:"RightPattern,omitempty"`
	ExtraComma   *expr.Keyword `protobuf:"bytes,6,opt,name=ExtraComma" json:"ExtraComma,omitempty"`
	CloseBracket *expr.Keyword `protobuf:"bytes,7,opt,name=CloseBracket" json:"CloseBracket,omitempty"`
}

func (m *Concat) Reset()      { *m = Concat{} }
func (*Concat) ProtoMessage() {}

func (m *Concat) GetOpenBracket() *expr.Keyword {
	if m != nil {
		return m.OpenBracket
	}
	return nil
}

func (m *Concat) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *Concat) GetComma() *expr.Keyword {
	if m != nil {
		return m.Comma
	}
	return nil
}

func (m *Concat) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *Concat) GetExtraComma() *expr.Keyword {
	if m != nil {
		return m.ExtraComma
	}
	return nil
}

func (m *Concat) GetCloseBracket() *expr.Keyword {
	if m != nil {
		return m.CloseBracket
	}
	return nil
}

type Or struct {
	OpenParen    *expr.Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	LeftPattern  *Pattern      `protobuf:"bytes,2,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	Pipe         *expr.Keyword `protobuf:"bytes,3,opt,name=Pipe" json:"Pipe,omitempty"`
	RightPattern *Pattern      `protobuf:"bytes,4,opt,name=RightPattern" json:"RightPattern,omitempty"`
	CloseParen   *expr.Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *Or) Reset()      { *m = Or{} }
func (*Or) ProtoMessage() {}

func (m *Or) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Or) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *Or) GetPipe() *expr.Keyword {
	if m != nil {
		return m.Pipe
	}
	return nil
}

func (m *Or) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *Or) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type And struct {
	OpenParen    *expr.Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	LeftPattern  *Pattern      `protobuf:"bytes,2,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	Ampersand    *expr.Keyword `protobuf:"bytes,3,opt,name=Ampersand" json:"Ampersand,omitempty"`
	RightPattern *Pattern      `protobuf:"bytes,4,opt,name=RightPattern" json:"RightPattern,omitempty"`
	CloseParen   *expr.Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *And) Reset()      { *m = And{} }
func (*And) ProtoMessage() {}

func (m *And) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *And) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *And) GetAmpersand() *expr.Keyword {
	if m != nil {
		return m.Ampersand
	}
	return nil
}

func (m *And) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *And) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type ZeroOrMore struct {
	OpenParen  *expr.Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Pattern    *Pattern      `protobuf:"bytes,2,opt,name=Pattern" json:"Pattern,omitempty"`
	CloseParen *expr.Keyword `protobuf:"bytes,3,opt,name=CloseParen" json:"CloseParen,omitempty"`
	Star       *expr.Keyword `protobuf:"bytes,4,opt,name=Star" json:"Star,omitempty"`
}

func (m *ZeroOrMore) Reset()      { *m = ZeroOrMore{} }
func (*ZeroOrMore) ProtoMessage() {}

func (m *ZeroOrMore) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *ZeroOrMore) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *ZeroOrMore) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

func (m *ZeroOrMore) GetStar() *expr.Keyword {
	if m != nil {
		return m.Star
	}
	return nil
}

type Reference struct {
	At   *expr.Keyword `protobuf:"bytes,1,opt,name=At" json:"At,omitempty"`
	Name string        `protobuf:"bytes,2,opt,name=Name" json:"Name"`
}

func (m *Reference) Reset()      { *m = Reference{} }
func (*Reference) ProtoMessage() {}

func (m *Reference) GetAt() *expr.Keyword {
	if m != nil {
		return m.At
	}
	return nil
}

func (m *Reference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Not struct {
	Exclamation *expr.Keyword `protobuf:"bytes,1,opt,name=Exclamation" json:"Exclamation,omitempty"`
	OpenParen   *expr.Keyword `protobuf:"bytes,2,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Pattern     *Pattern      `protobuf:"bytes,3,opt,name=Pattern" json:"Pattern,omitempty"`
	CloseParen  *expr.Keyword `protobuf:"bytes,4,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *Not) Reset()      { *m = Not{} }
func (*Not) ProtoMessage() {}

func (m *Not) GetExclamation() *expr.Keyword {
	if m != nil {
		return m.Exclamation
	}
	return nil
}

func (m *Not) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Not) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *Not) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

type ZAny struct {
	Star *expr.Keyword `protobuf:"bytes,1,opt,name=Star" json:"Star,omitempty"`
}

func (m *ZAny) Reset()      { *m = ZAny{} }
func (*ZAny) ProtoMessage() {}

func (m *ZAny) GetStar() *expr.Keyword {
	if m != nil {
		return m.Star
	}
	return nil
}

type Optional struct {
	OpenParen    *expr.Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Pattern      *Pattern      `protobuf:"bytes,2,opt,name=Pattern" json:"Pattern,omitempty"`
	CloseParen   *expr.Keyword `protobuf:"bytes,3,opt,name=CloseParen" json:"CloseParen,omitempty"`
	QuestionMark *expr.Keyword `protobuf:"bytes,4,opt,name=QuestionMark" json:"QuestionMark,omitempty"`
}

func (m *Optional) Reset()      { *m = Optional{} }
func (*Optional) ProtoMessage() {}

func (m *Optional) GetOpenParen() *expr.Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Optional) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *Optional) GetCloseParen() *expr.Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

func (m *Optional) GetQuestionMark() *expr.Keyword {
	if m != nil {
		return m.QuestionMark
	}
	return nil
}

type Interleave struct {
	OpenCurly      *expr.Keyword `protobuf:"bytes,2,opt,name=OpenCurly" json:"OpenCurly,omitempty"`
	LeftPattern    *Pattern      `protobuf:"bytes,3,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	SemiColon      *expr.Keyword `protobuf:"bytes,4,opt,name=SemiColon" json:"SemiColon,omitempty"`
	RightPattern   *Pattern      `protobuf:"bytes,5,opt,name=RightPattern" json:"RightPattern,omitempty"`
	ExtraSemiColon *expr.Keyword `protobuf:"bytes,6,opt,name=ExtraSemiColon" json:"ExtraSemiColon,omitempty"`
	CloseCurly     *expr.Keyword `protobuf:"bytes,7,opt,name=CloseCurly" json:"CloseCurly,omitempty"`
}

func (m *Interleave) Reset()      { *m = Interleave{} }
func (*Interleave) ProtoMessage() {}

func (m *Interleave) GetOpenCurly() *expr.Keyword {
	if m != nil {
		return m.OpenCurly
	}
	return nil
}

func (m *Interleave) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *Interleave) GetSemiColon() *expr.Keyword {
	if m != nil {
		return m.SemiColon
	}
	return nil
}

func (m *Interleave) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *Interleave) GetExtraSemiColon() *expr.Keyword {
	if m != nil {
		return m.ExtraSemiColon
	}
	return nil
}

func (m *Interleave) GetCloseCurly() *expr.Keyword {
	if m != nil {
		return m.CloseCurly
	}
	return nil
}

func init() {
	proto.RegisterType((*Grammar)(nil), "relapse.Grammar")
	proto.RegisterType((*PatternDecl)(nil), "relapse.PatternDecl")
	proto.RegisterType((*NameExpr)(nil), "relapse.NameExpr")
	proto.RegisterType((*Name)(nil), "relapse.Name")
	proto.RegisterType((*AnyName)(nil), "relapse.AnyName")
	proto.RegisterType((*AnyNameExcept)(nil), "relapse.AnyNameExcept")
	proto.RegisterType((*NameChoice)(nil), "relapse.NameChoice")
	proto.RegisterType((*Pattern)(nil), "relapse.Pattern")
	proto.RegisterType((*Empty)(nil), "relapse.Empty")
	proto.RegisterType((*TreeNode)(nil), "relapse.TreeNode")
	proto.RegisterType((*Contains)(nil), "relapse.Contains")
	proto.RegisterType((*LeafNode)(nil), "relapse.LeafNode")
	proto.RegisterType((*Concat)(nil), "relapse.Concat")
	proto.RegisterType((*Or)(nil), "relapse.Or")
	proto.RegisterType((*And)(nil), "relapse.And")
	proto.RegisterType((*ZeroOrMore)(nil), "relapse.ZeroOrMore")
	proto.RegisterType((*Reference)(nil), "relapse.Reference")
	proto.RegisterType((*Not)(nil), "relapse.Not")
	proto.RegisterType((*ZAny)(nil), "relapse.ZAny")
	proto.RegisterType((*Optional)(nil), "relapse.Optional")
	proto.RegisterType((*Interleave)(nil), "relapse.Interleave")
}
func (this *Grammar) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Grammar)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.TopPattern.Equal(that1.TopPattern) {
		return false
	}
	if len(this.PatternDecls) != len(that1.PatternDecls) {
		return false
	}
	for i := range this.PatternDecls {
		if !this.PatternDecls[i].Equal(that1.PatternDecls[i]) {
			return false
		}
	}
	if !this.After.Equal(that1.After) {
		return false
	}
	return true
}
func (this *PatternDecl) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PatternDecl)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Hash.Equal(that1.Hash) {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Eq.Equal(that1.Eq) {
		return false
	}
	if !this.Pattern.Equal(that1.Pattern) {
		return false
	}
	return true
}
func (this *NameExpr) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NameExpr)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Name.Equal(that1.Name) {
		return false
	}
	if !this.AnyName.Equal(that1.AnyName) {
		return false
	}
	if !this.AnyNameExcept.Equal(that1.AnyNameExcept) {
		return false
	}
	if !this.NameChoice.Equal(that1.NameChoice) {
		return false
	}
	return true
}
func (this *Name) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Name)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if this.DoubleValue != nil && that1.DoubleValue != nil {
		if *this.DoubleValue != *that1.DoubleValue {
			return false
		}
	} else if this.DoubleValue != nil {
		return false
	} else if that1.DoubleValue != nil {
		return false
	}
	if this.IntValue != nil && that1.IntValue != nil {
		if *this.IntValue != *that1.IntValue {
			return false
		}
	} else if this.IntValue != nil {
		return false
	} else if that1.IntValue != nil {
		return false
	}
	if this.UintValue != nil && that1.UintValue != nil {
		if *this.UintValue != *that1.UintValue {
			return false
		}
	} else if this.UintValue != nil {
		return false
	} else if that1.UintValue != nil {
		return false
	}
	if this.BoolValue != nil && that1.BoolValue != nil {
		if *this.BoolValue != *that1.BoolValue {
			return false
		}
	} else if this.BoolValue != nil {
		return false
	} else if that1.BoolValue != nil {
		return false
	}
	if this.StringValue != nil && that1.StringValue != nil {
		if *this.StringValue != *that1.StringValue {
			return false
		}
	} else if this.StringValue != nil {
		return false
	} else if that1.StringValue != nil {
		return false
	}
	if !bytes.Equal(this.BytesValue, that1.BytesValue) {
		return false
	}
	return true
}
func (this *AnyName) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AnyName)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Underscore.Equal(that1.Underscore) {
		return false
	}
	return true
}
func (this *AnyNameExcept) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AnyNameExcept)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Exclamation.Equal(that1.Exclamation) {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.Except.Equal(that1.Except) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	return true
}
func (this *NameChoice) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NameChoice)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.Left.Equal(that1.Left) {
		return false
	}
	if !this.Pipe.Equal(that1.Pipe) {
		return false
	}
	if !this.Right.Equal(that1.Right) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	return true
}
func (this *Pattern) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Pattern)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Empty.Equal(that1.Empty) {
		return false
	}
	if !this.TreeNode.Equal(that1.TreeNode) {
		return false
	}
	if !this.LeafNode.Equal(that1.LeafNode) {
		return false
	}
	if !this.Concat.Equal(that1.Concat) {
		return false
	}
	if !this.Or.Equal(that1.Or) {
		return false
	}
	if !this.And.Equal(that1.And) {
		return false
	}
	if !this.ZeroOrMore.Equal(that1.ZeroOrMore) {
		return false
	}
	if !this.Reference.Equal(that1.Reference) {
		return false
	}
	if !this.Not.Equal(that1.Not) {
		return false
	}
	if !this.ZAny.Equal(that1.ZAny) {
		return false
	}
	if !this.Contains.Equal(that1.Contains) {
		return false
	}
	if !this.Optional.Equal(that1.Optional) {
		return false
	}
	if !this.Interleave.Equal(that1.Interleave) {
		return false
	}
	return true
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Empty)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Empty.Equal(that1.Empty) {
		return false
	}
	return true
}
func (this *TreeNode) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeNode)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Name.Equal(that1.Name) {
		return false
	}
	if !this.Colon.Equal(that1.Colon) {
		return false
	}
	if !this.Pattern.Equal(that1.Pattern) {
		return false
	}
	return true
}
func (this *Contains) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Contains)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Dot.Equal(that1.Dot) {
		return false
	}
	if !this.Pattern.Equal(that1.Pattern) {
		return false
	}
	return true
}
func (this *LeafNode) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LeafNode)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.RightArrow.Equal(that1.RightArrow) {
		return false
	}
	if !this.Expr.Equal(that1.Expr) {
		return false
	}
	return true
}
func (this *Concat) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Concat)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenBracket.Equal(that1.OpenBracket) {
		return false
	}
	if !this.LeftPattern.Equal(that1.LeftPattern) {
		return false
	}
	if !this.Comma.Equal(that1.Comma) {
		return false
	}
	if !this.RightPattern.Equal(that1.RightPattern) {
		return false
	}
	if !this.ExtraComma.Equal(that1.ExtraComma) {
		return false
	}
	if !this.CloseBracket.Equal(that1.CloseBracket) {
		return false
	}
	return true
}
func (this *Or) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Or)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.LeftPattern.Equal(that1.LeftPattern) {
		return false
	}
	if !this.Pipe.Equal(that1.Pipe) {
		return false
	}
	if !this.RightPattern.Equal(that1.RightPattern) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	return true
}
func (this *And) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*And)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.LeftPattern.Equal(that1.LeftPattern) {
		return false
	}
	if !this.Ampersand.Equal(that1.Ampersand) {
		return false
	}
	if !this.RightPattern.Equal(that1.RightPattern) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	return true
}
func (this *ZeroOrMore) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ZeroOrMore)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.Pattern.Equal(that1.Pattern) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	if !this.Star.Equal(that1.Star) {
		return false
	}
	return true
}
func (this *Reference) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Reference)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.At.Equal(that1.At) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Not) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Not)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Exclamation.Equal(that1.Exclamation) {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.Pattern.Equal(that1.Pattern) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	return true
}
func (this *ZAny) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ZAny)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Star.Equal(that1.Star) {
		return false
	}
	return true
}
func (this *Optional) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Optional)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenParen.Equal(that1.OpenParen) {
		return false
	}
	if !this.Pattern.Equal(that1.Pattern) {
		return false
	}
	if !this.CloseParen.Equal(that1.CloseParen) {
		return false
	}
	if !this.QuestionMark.Equal(that1.QuestionMark) {
		return false
	}
	return true
}
func (this *Interleave) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Interleave)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OpenCurly.Equal(that1.OpenCurly) {
		return false
	}
	if !this.LeftPattern.Equal(that1.LeftPattern) {
		return false
	}
	if !this.SemiColon.Equal(that1.SemiColon) {
		return false
	}
	if !this.RightPattern.Equal(that1.RightPattern) {
		return false
	}
	if !this.ExtraSemiColon.Equal(that1.ExtraSemiColon) {
		return false
	}
	if !this.CloseCurly.Equal(that1.CloseCurly) {
		return false
	}
	return true
}
func (this *Grammar) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&relapse.Grammar{")
	if this.TopPattern != nil {
		s = append(s, "TopPattern: "+fmt.Sprintf("%#v", this.TopPattern)+",\n")
	}
	if this.PatternDecls != nil {
		s = append(s, "PatternDecls: "+fmt.Sprintf("%#v", this.PatternDecls)+",\n")
	}
	if this.After != nil {
		s = append(s, "After: "+fmt.Sprintf("%#v", this.After)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PatternDecl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&relapse.PatternDecl{")
	if this.Hash != nil {
		s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	}
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Eq != nil {
		s = append(s, "Eq: "+fmt.Sprintf("%#v", this.Eq)+",\n")
	}
	if this.Pattern != nil {
		s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NameExpr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&relapse.NameExpr{")
	if this.Name != nil {
		s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	}
	if this.AnyName != nil {
		s = append(s, "AnyName: "+fmt.Sprintf("%#v", this.AnyName)+",\n")
	}
	if this.AnyNameExcept != nil {
		s = append(s, "AnyNameExcept: "+fmt.Sprintf("%#v", this.AnyNameExcept)+",\n")
	}
	if this.NameChoice != nil {
		s = append(s, "NameChoice: "+fmt.Sprintf("%#v", this.NameChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Name) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&relapse.Name{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	if this.DoubleValue != nil {
		s = append(s, "DoubleValue: "+valueToGoStringRelapse(this.DoubleValue, "float64")+",\n")
	}
	if this.IntValue != nil {
		s = append(s, "IntValue: "+valueToGoStringRelapse(this.IntValue, "int64")+",\n")
	}
	if this.UintValue != nil {
		s = append(s, "UintValue: "+valueToGoStringRelapse(this.UintValue, "uint64")+",\n")
	}
	if this.BoolValue != nil {
		s = append(s, "BoolValue: "+valueToGoStringRelapse(this.BoolValue, "bool")+",\n")
	}
	if this.StringValue != nil {
		s = append(s, "StringValue: "+valueToGoStringRelapse(this.StringValue, "string")+",\n")
	}
	if this.BytesValue != nil {
		s = append(s, "BytesValue: "+valueToGoStringRelapse(this.BytesValue, "byte")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AnyName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&relapse.AnyName{")
	if this.Underscore != nil {
		s = append(s, "Underscore: "+fmt.Sprintf("%#v", this.Underscore)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AnyNameExcept) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&relapse.AnyNameExcept{")
	if this.Exclamation != nil {
		s = append(s, "Exclamation: "+fmt.Sprintf("%#v", this.Exclamation)+",\n")
	}
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.Except != nil {
		s = append(s, "Except: "+fmt.Sprintf("%#v", this.Except)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NameChoice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&relapse.NameChoice{")
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.Left != nil {
		s = append(s, "Left: "+fmt.Sprintf("%#v", this.Left)+",\n")
	}
	if this.Pipe != nil {
		s = append(s, "Pipe: "+fmt.Sprintf("%#v", this.Pipe)+",\n")
	}
	if this.Right != nil {
		s = append(s, "Right: "+fmt.Sprintf("%#v", this.Right)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Pattern) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&relapse.Pattern{")
	if this.Empty != nil {
		s = append(s, "Empty: "+fmt.Sprintf("%#v", this.Empty)+",\n")
	}
	if this.TreeNode != nil {
		s = append(s, "TreeNode: "+fmt.Sprintf("%#v", this.TreeNode)+",\n")
	}
	if this.LeafNode != nil {
		s = append(s, "LeafNode: "+fmt.Sprintf("%#v", this.LeafNode)+",\n")
	}
	if this.Concat != nil {
		s = append(s, "Concat: "+fmt.Sprintf("%#v", this.Concat)+",\n")
	}
	if this.Or != nil {
		s = append(s, "Or: "+fmt.Sprintf("%#v", this.Or)+",\n")
	}
	if this.And != nil {
		s = append(s, "And: "+fmt.Sprintf("%#v", this.And)+",\n")
	}
	if this.ZeroOrMore != nil {
		s = append(s, "ZeroOrMore: "+fmt.Sprintf("%#v", this.ZeroOrMore)+",\n")
	}
	if this.Reference != nil {
		s = append(s, "Reference: "+fmt.Sprintf("%#v", this.Reference)+",\n")
	}
	if this.Not != nil {
		s = append(s, "Not: "+fmt.Sprintf("%#v", this.Not)+",\n")
	}
	if this.ZAny != nil {
		s = append(s, "ZAny: "+fmt.Sprintf("%#v", this.ZAny)+",\n")
	}
	if this.Contains != nil {
		s = append(s, "Contains: "+fmt.Sprintf("%#v", this.Contains)+",\n")
	}
	if this.Optional != nil {
		s = append(s, "Optional: "+fmt.Sprintf("%#v", this.Optional)+",\n")
	}
	if this.Interleave != nil {
		s = append(s, "Interleave: "+fmt.Sprintf("%#v", this.Interleave)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&relapse.Empty{")
	if this.Empty != nil {
		s = append(s, "Empty: "+fmt.Sprintf("%#v", this.Empty)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TreeNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&relapse.TreeNode{")
	if this.Name != nil {
		s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	}
	if this.Colon != nil {
		s = append(s, "Colon: "+fmt.Sprintf("%#v", this.Colon)+",\n")
	}
	if this.Pattern != nil {
		s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Contains) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&relapse.Contains{")
	if this.Dot != nil {
		s = append(s, "Dot: "+fmt.Sprintf("%#v", this.Dot)+",\n")
	}
	if this.Pattern != nil {
		s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LeafNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&relapse.LeafNode{")
	if this.RightArrow != nil {
		s = append(s, "RightArrow: "+fmt.Sprintf("%#v", this.RightArrow)+",\n")
	}
	if this.Expr != nil {
		s = append(s, "Expr: "+fmt.Sprintf("%#v", this.Expr)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Concat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&relapse.Concat{")
	if this.OpenBracket != nil {
		s = append(s, "OpenBracket: "+fmt.Sprintf("%#v", this.OpenBracket)+",\n")
	}
	if this.LeftPattern != nil {
		s = append(s, "LeftPattern: "+fmt.Sprintf("%#v", this.LeftPattern)+",\n")
	}
	if this.Comma != nil {
		s = append(s, "Comma: "+fmt.Sprintf("%#v", this.Comma)+",\n")
	}
	if this.RightPattern != nil {
		s = append(s, "RightPattern: "+fmt.Sprintf("%#v", this.RightPattern)+",\n")
	}
	if this.ExtraComma != nil {
		s = append(s, "ExtraComma: "+fmt.Sprintf("%#v", this.ExtraComma)+",\n")
	}
	if this.CloseBracket != nil {
		s = append(s, "CloseBracket: "+fmt.Sprintf("%#v", this.CloseBracket)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Or) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&relapse.Or{")
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.LeftPattern != nil {
		s = append(s, "LeftPattern: "+fmt.Sprintf("%#v", this.LeftPattern)+",\n")
	}
	if this.Pipe != nil {
		s = append(s, "Pipe: "+fmt.Sprintf("%#v", this.Pipe)+",\n")
	}
	if this.RightPattern != nil {
		s = append(s, "RightPattern: "+fmt.Sprintf("%#v", this.RightPattern)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *And) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&relapse.And{")
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.LeftPattern != nil {
		s = append(s, "LeftPattern: "+fmt.Sprintf("%#v", this.LeftPattern)+",\n")
	}
	if this.Ampersand != nil {
		s = append(s, "Ampersand: "+fmt.Sprintf("%#v", this.Ampersand)+",\n")
	}
	if this.RightPattern != nil {
		s = append(s, "RightPattern: "+fmt.Sprintf("%#v", this.RightPattern)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ZeroOrMore) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&relapse.ZeroOrMore{")
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.Pattern != nil {
		s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	if this.Star != nil {
		s = append(s, "Star: "+fmt.Sprintf("%#v", this.Star)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Reference) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&relapse.Reference{")
	if this.At != nil {
		s = append(s, "At: "+fmt.Sprintf("%#v", this.At)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Not) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&relapse.Not{")
	if this.Exclamation != nil {
		s = append(s, "Exclamation: "+fmt.Sprintf("%#v", this.Exclamation)+",\n")
	}
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.Pattern != nil {
		s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ZAny) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&relapse.ZAny{")
	if this.Star != nil {
		s = append(s, "Star: "+fmt.Sprintf("%#v", this.Star)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Optional) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&relapse.Optional{")
	if this.OpenParen != nil {
		s = append(s, "OpenParen: "+fmt.Sprintf("%#v", this.OpenParen)+",\n")
	}
	if this.Pattern != nil {
		s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	}
	if this.CloseParen != nil {
		s = append(s, "CloseParen: "+fmt.Sprintf("%#v", this.CloseParen)+",\n")
	}
	if this.QuestionMark != nil {
		s = append(s, "QuestionMark: "+fmt.Sprintf("%#v", this.QuestionMark)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Interleave) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&relapse.Interleave{")
	if this.OpenCurly != nil {
		s = append(s, "OpenCurly: "+fmt.Sprintf("%#v", this.OpenCurly)+",\n")
	}
	if this.LeftPattern != nil {
		s = append(s, "LeftPattern: "+fmt.Sprintf("%#v", this.LeftPattern)+",\n")
	}
	if this.SemiColon != nil {
		s = append(s, "SemiColon: "+fmt.Sprintf("%#v", this.SemiColon)+",\n")
	}
	if this.RightPattern != nil {
		s = append(s, "RightPattern: "+fmt.Sprintf("%#v", this.RightPattern)+",\n")
	}
	if this.ExtraSemiColon != nil {
		s = append(s, "ExtraSemiColon: "+fmt.Sprintf("%#v", this.ExtraSemiColon)+",\n")
	}
	if this.CloseCurly != nil {
		s = append(s, "CloseCurly: "+fmt.Sprintf("%#v", this.CloseCurly)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringRelapse(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringRelapse(e map[int32]github_com_gogo_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func (this *NameExpr) GetValue() interface{} {
	if this.Name != nil {
		return this.Name
	}
	if this.AnyName != nil {
		return this.AnyName
	}
	if this.AnyNameExcept != nil {
		return this.AnyNameExcept
	}
	if this.NameChoice != nil {
		return this.NameChoice
	}
	return nil
}

func (this *NameExpr) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *Name:
		this.Name = vt
	case *AnyName:
		this.AnyName = vt
	case *AnyNameExcept:
		this.AnyNameExcept = vt
	case *NameChoice:
		this.NameChoice = vt
	default:
		return false
	}
	return true
}
func (this *Pattern) GetValue() interface{} {
	if this.Empty != nil {
		return this.Empty
	}
	if this.TreeNode != nil {
		return this.TreeNode
	}
	if this.LeafNode != nil {
		return this.LeafNode
	}
	if this.Concat != nil {
		return this.Concat
	}
	if this.Or != nil {
		return this.Or
	}
	if this.And != nil {
		return this.And
	}
	if this.ZeroOrMore != nil {
		return this.ZeroOrMore
	}
	if this.Reference != nil {
		return this.Reference
	}
	if this.Not != nil {
		return this.Not
	}
	if this.ZAny != nil {
		return this.ZAny
	}
	if this.Contains != nil {
		return this.Contains
	}
	if this.Optional != nil {
		return this.Optional
	}
	if this.Interleave != nil {
		return this.Interleave
	}
	return nil
}

func (this *Pattern) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *Empty:
		this.Empty = vt
	case *TreeNode:
		this.TreeNode = vt
	case *LeafNode:
		this.LeafNode = vt
	case *Concat:
		this.Concat = vt
	case *Or:
		this.Or = vt
	case *And:
		this.And = vt
	case *ZeroOrMore:
		this.ZeroOrMore = vt
	case *Reference:
		this.Reference = vt
	case *Not:
		this.Not = vt
	case *ZAny:
		this.ZAny = vt
	case *Contains:
		this.Contains = vt
	case *Optional:
		this.Optional = vt
	case *Interleave:
		this.Interleave = vt
	default:
		return false
	}
	return true
}
