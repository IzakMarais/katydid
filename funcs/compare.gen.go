// Code generated by funcs-gen.
// DO NOT EDIT!

package funcs

import (
	"bytes"
)

type doubleGE struct {
	V1 Double
	V2 Double
}

func (this *doubleGE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 >= v2, nil
}

func init() {
	Register("ge", new(doubleGE))
}

func DoubleGE(a, b Double) Bool {
	return &doubleGE{V1: a, V2: b}
}

func DoubleVarGE(a Double) Bool {
	return &doubleGE{V1: a, V2: DoubleVar()}
}

type intGE struct {
	V1 Int
	V2 Int
}

func (this *intGE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 >= v2, nil
}

func init() {
	Register("ge", new(intGE))
}

func IntGE(a, b Int) Bool {
	return &intGE{V1: a, V2: b}
}

func IntVarGE(a Int) Bool {
	return &intGE{V1: a, V2: IntVar()}
}

type uintGE struct {
	V1 Uint
	V2 Uint
}

func (this *uintGE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 >= v2, nil
}

func init() {
	Register("ge", new(uintGE))
}

func UintGE(a, b Uint) Bool {
	return &uintGE{V1: a, V2: b}
}

func UintVarGE(a Uint) Bool {
	return &uintGE{V1: a, V2: UintVar()}
}

type bytesGE struct {
	V1 Bytes
	V2 Bytes
}

func (this *bytesGE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return bytes.Compare(v1, v2) >= 0, nil
}

func init() {
	Register("ge", new(bytesGE))
}

func BytesGE(a, b Bytes) Bool {
	return &bytesGE{V1: a, V2: b}
}

func BytesVarGE(a Bytes) Bool {
	return &bytesGE{V1: a, V2: BytesVar()}
}

type doubleGt struct {
	V1 Double
	V2 Double
}

func (this *doubleGt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return v1 > v2, nil
}

func init() {
	Register("gt", new(doubleGt))
}

func DoubleGt(a, b Double) Bool {
	return &doubleGt{V1: a, V2: b}
}

func DoubleVarGt(a Double) Bool {
	return &doubleGt{V1: a, V2: DoubleVar()}
}

type intGt struct {
	V1 Int
	V2 Int
}

func (this *intGt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return v1 > v2, nil
}

func init() {
	Register("gt", new(intGt))
}

func IntGt(a, b Int) Bool {
	return &intGt{V1: a, V2: b}
}

func IntVarGt(a Int) Bool {
	return &intGt{V1: a, V2: IntVar()}
}

type uintGt struct {
	V1 Uint
	V2 Uint
}

func (this *uintGt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return v1 > v2, nil
}

func init() {
	Register("gt", new(uintGt))
}

func UintGt(a, b Uint) Bool {
	return &uintGt{V1: a, V2: b}
}

func UintVarGt(a Uint) Bool {
	return &uintGt{V1: a, V2: UintVar()}
}

type bytesGt struct {
	V1 Bytes
	V2 Bytes
}

func (this *bytesGt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return bytes.Compare(v1, v2) > 0, nil
}

func init() {
	Register("gt", new(bytesGt))
}

func BytesGt(a, b Bytes) Bool {
	return &bytesGt{V1: a, V2: b}
}

func BytesVarGt(a Bytes) Bool {
	return &bytesGt{V1: a, V2: BytesVar()}
}

type doubleLE struct {
	V1 Double
	V2 Double
}

func (this *doubleLE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 <= v2, nil
}

func init() {
	Register("le", new(doubleLE))
}

func DoubleLE(a, b Double) Bool {
	return &doubleLE{V1: a, V2: b}
}

func DoubleVarLE(a Double) Bool {
	return &doubleLE{V1: a, V2: DoubleVar()}
}

type intLE struct {
	V1 Int
	V2 Int
}

func (this *intLE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 <= v2, nil
}

func init() {
	Register("le", new(intLE))
}

func IntLE(a, b Int) Bool {
	return &intLE{V1: a, V2: b}
}

func IntVarLE(a Int) Bool {
	return &intLE{V1: a, V2: IntVar()}
}

type uintLE struct {
	V1 Uint
	V2 Uint
}

func (this *uintLE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 <= v2, nil
}

func init() {
	Register("le", new(uintLE))
}

func UintLE(a, b Uint) Bool {
	return &uintLE{V1: a, V2: b}
}

func UintVarLE(a Uint) Bool {
	return &uintLE{V1: a, V2: UintVar()}
}

type bytesLE struct {
	V1 Bytes
	V2 Bytes
}

func (this *bytesLE) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return bytes.Compare(v1, v2) <= 0, nil
}

func init() {
	Register("le", new(bytesLE))
}

func BytesLE(a, b Bytes) Bool {
	return &bytesLE{V1: a, V2: b}
}

func BytesVarLE(a Bytes) Bool {
	return &bytesLE{V1: a, V2: BytesVar()}
}

type doubleLt struct {
	V1 Double
	V2 Double
}

func (this *doubleLt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return v1 < v2, nil
}

func init() {
	Register("lt", new(doubleLt))
}

func DoubleLt(a, b Double) Bool {
	return &doubleLt{V1: a, V2: b}
}

func DoubleVarLt(a Double) Bool {
	return &doubleLt{V1: a, V2: DoubleVar()}
}

type intLt struct {
	V1 Int
	V2 Int
}

func (this *intLt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return v1 < v2, nil
}

func init() {
	Register("lt", new(intLt))
}

func IntLt(a, b Int) Bool {
	return &intLt{V1: a, V2: b}
}

func IntVarLt(a Int) Bool {
	return &intLt{V1: a, V2: IntVar()}
}

type uintLt struct {
	V1 Uint
	V2 Uint
}

func (this *uintLt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return v1 < v2, nil
}

func init() {
	Register("lt", new(uintLt))
}

func UintLt(a, b Uint) Bool {
	return &uintLt{V1: a, V2: b}
}

func UintVarLt(a Uint) Bool {
	return &uintLt{V1: a, V2: UintVar()}
}

type bytesLt struct {
	V1 Bytes
	V2 Bytes
}

func (this *bytesLt) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return bytes.Compare(v1, v2) < 0, nil
}

func init() {
	Register("lt", new(bytesLt))
}

func BytesLt(a, b Bytes) Bool {
	return &bytesLt{V1: a, V2: b}
}

func BytesVarLt(a Bytes) Bool {
	return &bytesLt{V1: a, V2: BytesVar()}
}

type doubleEq struct {
	V1 Double
	V2 Double
}

func (this *doubleEq) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 == v2, nil
}

func init() {
	Register("eq", new(doubleEq))
}

func DoubleEq(a, b Double) Bool {
	return &doubleEq{V1: a, V2: b}
}

func DoubleVarEq(a Double) Bool {
	return &doubleEq{V1: a, V2: DoubleVar()}
}

type intEq struct {
	V1 Int
	V2 Int
}

func (this *intEq) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 == v2, nil
}

func init() {
	Register("eq", new(intEq))
}

func IntEq(a, b Int) Bool {
	return &intEq{V1: a, V2: b}
}

func IntVarEq(a Int) Bool {
	return &intEq{V1: a, V2: IntVar()}
}

type uintEq struct {
	V1 Uint
	V2 Uint
}

func (this *uintEq) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 == v2, nil
}

func init() {
	Register("eq", new(uintEq))
}

func UintEq(a, b Uint) Bool {
	return &uintEq{V1: a, V2: b}
}

func UintVarEq(a Uint) Bool {
	return &uintEq{V1: a, V2: UintVar()}
}

type boolEq struct {
	V1 Bool
	V2 Bool
}

func (this *boolEq) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 == v2, nil
}

func init() {
	Register("eq", new(boolEq))
}

func BoolEq(a, b Bool) Bool {
	return &boolEq{V1: a, V2: b}
}

func BoolVarEq(a Bool) Bool {
	return &boolEq{V1: a, V2: BoolVar()}
}

type stringEq struct {
	V1 String
	V2 String
}

func (this *stringEq) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return v1 == v2, nil
}

func init() {
	Register("eq", new(stringEq))
}

func StringEq(a, b String) Bool {
	return &stringEq{V1: a, V2: b}
}

func StringVarEq(a String) Bool {
	return &stringEq{V1: a, V2: StringVar()}
}

type bytesEq struct {
	V1 Bytes
	V2 Bytes
}

func (this *bytesEq) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return false, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return false, nil
	}
	return bytes.Equal(v1, v2), nil
}

func init() {
	Register("eq", new(bytesEq))
}

func BytesEq(a, b Bytes) Bool {
	return &bytesEq{V1: a, V2: b}
}

func BytesVarEq(a Bytes) Bool {
	return &bytesEq{V1: a, V2: BytesVar()}
}

type doubleNe struct {
	V1 Double
	V2 Double
}

func (this *doubleNe) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return v1 != v2, nil
}

func init() {
	Register("ne", new(doubleNe))
}

func DoubleNe(a, b Double) Bool {
	return &doubleNe{V1: a, V2: b}
}

func DoubleVarNe(a Double) Bool {
	return &doubleNe{V1: a, V2: DoubleVar()}
}

type intNe struct {
	V1 Int
	V2 Int
}

func (this *intNe) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return v1 != v2, nil
}

func init() {
	Register("ne", new(intNe))
}

func IntNe(a, b Int) Bool {
	return &intNe{V1: a, V2: b}
}

func IntVarNe(a Int) Bool {
	return &intNe{V1: a, V2: IntVar()}
}

type uintNe struct {
	V1 Uint
	V2 Uint
}

func (this *uintNe) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return v1 != v2, nil
}

func init() {
	Register("ne", new(uintNe))
}

func UintNe(a, b Uint) Bool {
	return &uintNe{V1: a, V2: b}
}

func UintVarNe(a Uint) Bool {
	return &uintNe{V1: a, V2: UintVar()}
}

type boolNe struct {
	V1 Bool
	V2 Bool
}

func (this *boolNe) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return v1 != v2, nil
}

func init() {
	Register("ne", new(boolNe))
}

func BoolNe(a, b Bool) Bool {
	return &boolNe{V1: a, V2: b}
}

func BoolVarNe(a Bool) Bool {
	return &boolNe{V1: a, V2: BoolVar()}
}

type stringNe struct {
	V1 String
	V2 String
}

func (this *stringNe) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return v1 != v2, nil
}

func init() {
	Register("ne", new(stringNe))
}

func StringNe(a, b String) Bool {
	return &stringNe{V1: a, V2: b}
}

func StringVarNe(a String) Bool {
	return &stringNe{V1: a, V2: StringVar()}
}

type bytesNe struct {
	V1 Bytes
	V2 Bytes
}

func (this *bytesNe) Eval() (bool, error) {
	v1, err := this.V1.Eval()
	if err != nil {
		return true, nil
	}
	v2, err := this.V2.Eval()
	if err != nil {
		return true, nil
	}
	return !bytes.Equal(v1, v2), nil
}

func init() {
	Register("ne", new(bytesNe))
}

func BytesNe(a, b Bytes) Bool {
	return &bytesNe{V1: a, V2: b}
}

func BytesVarNe(a Bytes) Bool {
	return &bytesNe{V1: a, V2: BytesVar()}
}
